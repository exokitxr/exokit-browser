<!doctype html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
    <!-- <canvas id="canvas"></canvas> -->
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="TransformControls.js"></script>
    <script src="BufferGeometryUtils.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="LegacyGLTFLoader.js"></script>
    <!-- <script src="localforage.js"></script> -->
    <script src="bmfont.js"></script>
    <script src="keycode.js"></script>
    <script src="svg-boundings.js"></script>
    <script src="cubicBezier.js"></script>
    <!-- <script src="sprite3d.js"></script> -->
    <script src="land.js"></script>
    <!-- <script src="skin.js"></script> -->
    <script src="three-ik.js"></script>
    <script src="parse5.js"></script>
    <script src="html-beautify.js"></script>
    <script src="file-type.js"></script>
    <script src="namegen.js"></script>
  </head>
  <body>
    <xr-site></xr-site>
    <script type=module>
import RiggedModel from './avatar/proto/IKRiggedModel.js';
import './avatar/proto/model.patches.js';

(async () => {

let session, display, fakeXrDisplay, lastPresseds = [false, false], lastGripped = [false, false], lastPads = [false, false], lastAxes = [[0.5, 0.5], [0.5, 0.5]], lastPadToucheds = [false, false], scrollFactors = [0, 0], scaleFactors = [1, 1], menuOpen = false, orbitControls = null, transformControls, currentMoveMeshes = [null, null], moveMeshes = [], assetMeshes = [], moveLabelMeshes = [], assetLabelMeshes = [], nativeLabelMeshes = [], guardianMeshes = [], baseMeshes = [], menuAnimation = null, menuFactor = 1, keyboardFocus = null, user = null;
const mouse = {
  position: new THREE.Vector3(),
  quaternion: new THREE.Quaternion(),
};
const colors = {
  default: 0x42a5f5,
  highlight: 0x9ccc65,
};
const _rewriteUrlToRaw = u => {
  const o = new URL(u);
  const match = o.host.match(/^(.+)\.proxy\.exokit\.org$/);
  const raw = match[1];
  const match2 = raw.match(/^(https?-)(.+?)(-[0-9]+)?$/);
  o.protocol = match2[1].replace(/-/g, ':');
  o.host = match2[2].replace(/--/g, '=').replace(/-/g, '.').replace(/=/g, '-').replace(/\.\./g, '-') + (match2[3] ? match2[3].replace(/-/g, ':') : '');
  return o.href;
};

const LAMBDA_URLS = {
  login: `https://login.exokit.org/`,
  token: `https://token.exokit.org/token`,
  tokens: `https://token.exokit.org/tokens`,
  coords: `https://token.exokit.org/coords`,
  presence: `https://presence.exokit.org/`,
  presenceWs: `wss://presence.exokit.org/`,
  inventory: `https://inventory.exokit.org/`,
};
// const DEFAULT_URL = '/examples/tutorial.html';
// const DEFAULT_URL = 'https://exokitxr.github.io/examples/tutorial.html';
// const DEFAULT_URL = 'https://web.exokit.org/examples/tutorial.html';
// const DEFAULT_URL = 'https://rawcdn.githack.com/exokitxr/webxr-samples/8a13dcbb22fa52feadfab7b7f41f85bdb3601a3f/xr-presentation.html';
const DEFAULT_URL = 'https://aframe.io/a-painter';
// const DEFAULT_URL = 'https://hubs.mozilla.com/VxGmqjU/fuchsia-winding-room?vr_entry_type=vr_now';
// const DEFAULT_URL = 'https://moonrider.xyz/';
// const DEFAULT_URL = 'https://www.cryptovoxels.com/play?vr=enabled';
const PARCEL_SIZE = 8;
const TOKEN_PRICE = 5e15;
const DEFAULT_SKIN_URL = 'skin.png';
const RAY_COLOR = 0x44c2ff;
const RAY_HIGHLIGHT_COLOR = new THREE.Color(RAY_COLOR).multiplyScalar(0.5).getHex();
const rayDistance = 3;
const menuWidth = 1024;
const menuHeight = menuWidth * 0.1;
const menuWorldWidth = 1;
const menuWorldHeight = menuWorldWidth / menuWidth * menuHeight;
const menuPositionHeight = 0.3;
const keyboardWidth = 2048;
const keyboardHeight = 716;
const keyboardMatrix = [keyboardWidth / 963.266, keyboardHeight / 337.215];
const cursorWidth = 4;
const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));
const DIRECTIONS = [
  new THREE.Vector3(1, 0, 0),
  new THREE.Vector3(-1, 0, 0),
  new THREE.Vector3(0, 0, 1),
  new THREE.Vector3(0, 0, -1),
];
const directionVectors = (() => {
  const result = Array(DIRECTIONS.length);
  for (let i = 0; i < DIRECTIONS.length; i++) {
    result[i] = new THREE.Vector3();
  }
  return result;
})();

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localVector4 = new THREE.Vector3();
const localVector2D = new THREE.Vector2();
const localQuaternion = new THREE.Quaternion();
const localQuaternion2 = new THREE.Quaternion();
const localQuaternion3 = new THREE.Quaternion();
const localEuler = new THREE.Euler(0, 0, 0, 'YXZ');
const localEuler2 = new THREE.Euler(0, 0, 0, 'YXZ');
const localMatrix = new THREE.Matrix4();
const localMatrix2 = new THREE.Matrix4();
const localLine = new THREE.Line3();
const localBox = new THREE.Box3();
const localRay = new THREE.Ray();
const localRaycaster = new THREE.Raycaster();
const localPlane = new THREE.Plane();
const localCamera = new THREE.PerspectiveCamera();

function parseQuery(s) {
  var query = {};
  var pairs = (s[0] === '?' ? s.substr(1) : s).split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  return query;
}
function _randomString() {
  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
}
function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
function _getChildNodeIndex(childEl) {
  let i = 0;
  while(childEl = childEl.previousSibling) {
    i++;
  }
  return i;
}
function _findElByKeyPath(el, keyPath) {
  for (let i = 0; i < keyPath.length; i++) {
    const key = keyPath[i];
    let match;
    if (typeof key === 'number') {
      el = el.childNodes[key] || null;
    } else if (typeof key === 'string' && (match = key.match(/^#(.+)$/))) {
      const id = match[1];
      const matchEl = Array.from(el.childNodes).find(childEl => childEl.id === id) || null;
      if (matchEl) {
        el = matchEl;
      } else {
        const _findRecursive = el => {
          const xrIframes = el.querySelectorAll('xr-iframe');
          for (let i = 0; i < xrIframes.length; i++) {
            const xrIframe = xrIframes[i];
            if (xrIframe.id === id) {
              return xrIframe;
            } else if (xrIframe.loaded) {
              return _findRecursive(xrIframe.contentWindow.iframe.contentDocument);
            } else {
              return null;
            }
          }
        };
        return _findRecursive(el);
      }
    } else {
      el = null;
    }
    if (!el) {
      break;
    }
  }
  return el;
}
function _parseHtml(s) {
  const div = document.createElement('div');
  div.innerHTML = s;
  return div.childNodes[0] || null;
}
XRSite.prototype.getHTML = function getHTML() {
  return html_beautify(this.outerHTML);
};
XRSite.prototype.setHTML = function setHTML(htmlString) {
  const dom = new DOMParser().parseFromString(htmlString, 'text/html');
  const xrSite = Array.from(dom.body.childNodes).find(el => el.nodeName === 'XR-SITE');
  if (xrSite) {
    this.innerHTML = xrSite.innerHTML;
    return true;
  } else {
    return false;
  }
};
XRSite.prototype.update = function update() {
  this.handleMutations(this.observer.takeRecords());
};
XRSite.prototype.handleMutations = function handleMutations(mutations) {
  for (let i = 0; i < mutations.length; i++) {
    const {addedNodes, removedNodes} = mutations[i];

    for (let j = 0; j < removedNodes.length; j++) {
      const removedNode = removedNodes[j];

      if (removedNode instanceof XRIFrame) {
        const xrIframe = removedNode;

        layers.splice(layers.indexOf(xrIframe), 1);

        if (xrIframe.native) {
          const {labelMesh} = xrIframe;
          scene.remove(labelMesh);
          xrIframe.labelMesh = null;
          nativeLabelMeshes.splice(nativeLabelMeshes.indexOf(labelMesh), 1);
        } else {
          const {moveMesh} = xrIframe;
          scene.remove(moveMesh);
          scene.remove(moveMesh.labelMesh);
          moveLabelMeshes.splice(moveLabelMeshes.indexOf(moveMesh), 1);
        }
      }
    }
    for (let j = 0; j < addedNodes.length; j++) {
      const addedNode = addedNodes[j];

      if (addedNode instanceof XRIFrame) {
        const xrIframe = addedNode;

        layers.push(xrIframe);

        if (xrIframe.native) {
          const labelMesh = _makeLabelMesh(xrIframe.name || xrIframe.src, 'raw');
          scene.add(labelMesh);
          xrIframe.labelMesh = labelMesh;
          nativeLabelMeshes.push(labelMesh);
        } else {
          const moveMesh = _makeMoveMesh('volume');
          moveMesh.position.fromArray(xrIframe.position);
          moveMesh.quaternion.fromArray(xrIframe.orientation);
          moveMesh.scale.fromArray(xrIframe.scale);
          moveMesh.xrIframe = xrIframe;
          moveMesh.startTime = Date.now();
          scene.add(moveMesh);
          moveMeshes.push(moveMesh);
          xrIframe.moveMesh = moveMesh;

          const labelMesh = _makeLabelMesh(xrIframe.name || xrIframe.src, 'remove');
          labelMesh.moveMesh = moveMesh;
          labelMesh.xrIframe = xrIframe;
          moveMesh.labelMesh = labelMesh;
          scene.add(labelMesh);
          moveLabelMeshes.push(labelMesh);
        }
      }
    }
  }
};
const clipboard = {
  copy(text) {
    const fakeElem = document.body.appendChild(document.createElement('textarea'));
    fakeElem.style.position = 'absolute';
    fakeElem.style.left = '-9999px';
    fakeElem.setAttribute('readonly', '');
    fakeElem.value = text;
    fakeElem.select();
    try {
      return document.execCommand('copy');
    } catch (err) {
      return false;
    } finally {
      fakeElem.parentNode.removeChild(fakeElem);
    }
  },
  paste() {
    const fakeElem = document.body.appendChild(document.createElement('textarea'));
    fakeElem.style.position = 'absolute';
    fakeElem.style.left = '-9999px';
    fakeElem.setAttribute('readonly', '');
    fakeElem.select();
    fakeElem.parentNode.removeChild(fakeElem);

    return navigator.clipboard.readText()
      .catch(err => {
        console.warn(err);

        return navigator.permissions.query({
          name: 'clipboard-read',
        })
        .then(async permissionStatus => {
          // Will be 'granted', 'denied' or 'prompt':
          console.log('permission 1', permissionStatus.state);

          if (permissionStatus.state !== 'granted') {
            // Listen for changes to the permission state
            await new Promise((accept, reject) => {
              permissionStatus.onchange = () => {
                console.log('permission 2', permissionStatus.state);
                if (permissionStatus.state === 'granted') {
                  permissionStatus.onchange = null;
                  accept();
                }
              };
            });
          }
        })
        .then(() => navigator.clipboard.readText());
      });
  },
};
const _makeNullPromise = () => {
  let resolve, reject;
  const result = new Promise((a, b) => {
    resolve = a;
    reject = b;
  });
  result.resolve = resolve;
  result.reject = reject;
  return result;
};
const _normalizeEl = el => ({
  nodeName: el.nodeName,
  tagName: el.tagName,
  attrs: el.attrs,
  value: el.value,
  childNodes: el.childNodes ? el.childNodes.map(childEl => _normalizeEl(childEl)) : [],
});

const loginPromise = _makeNullPromise();
let loginToken;
const root = document.querySelector('xr-site');
root.observer = new MutationObserver(mutations => {
  root.handleMutations(mutations);
});
root.observer.observe(root, {
  childList: true,
});
new MutationObserver(mutations => {
  for (let i = 0; i < mutations.length; i++) {
    const mutation = mutations[i];
    const {target, attributeName} = mutation;
    if (target instanceof XRIFrame) {
      const xrIframe = target;
      const {moveMesh} = xrIframe;
      if (attributeName === 'position') {
        moveMesh.position.fromArray(xrIframe.position);
      } else if (attributeName === 'orientation') {
        moveMesh.quaternion.fromArray(xrIframe.orientation);
      } else if (attributeName === 'scale') {
        moveMesh.scale.fromArray(xrIframe.scale);
      }
    }
  }
}).observe(root, {
  attributeFilter: ['position', 'orientation', 'scale'],
  attributes: true,
  subtree: true,
});

class RiggedModel {
  constructor(avatarMesh) {
    this.avatarMesh = avatarMesh;
  }
  setState(hmd, gamepads) {
    this.avatarMesh.position.fromArray(hmd.position).sub(localVector.set(0, 1.5, 0));
    localQuaternion.fromArray(hmd.quaternion);
    localEuler.setFromQuaternion(localQuaternion, localEuler.order);
    localEuler.y += Math.PI;
    localEuler.x *= -1;
    this.avatarMesh.quaternion.setFromEuler(localEuler);
  }
  update() {
    // console.log('per-frame update called');
  }
}
const _makePeerConnection = peerConnectionId => {
  const peerConnectionConfig = {
    iceServers: [
      {'urls': 'stun:stun.stunprotocol.org:3478'},
      {'urls': 'stun:stun.l.google.com:19302'},
    ],
  };

  const peerConnection = new RTCPeerConnection(peerConnectionConfig);
  peerConnection.ontrack = e => {
    console.log('got track', e);
  };

  let avatarMesh = null;
  const sendChannel = peerConnection.createDataChannel('sendChannel');
  peerConnection.sendChannel = sendChannel;
  let pingInterval = 0;
  let updateInterval = 0;
  sendChannel.onopen = () => {
    // console.log('data channel local open');

    avatarMesh = new THREE.Object3D();
    avatarMesh.riggedModel = null;
    const loader = new THREE.GLTFLoader();
    loader.load('https://modulesio.github.io/models/miku.glb', object => {
      if (avatarMesh) {
        avatarMesh.riggedModel = new RiggedModel(object.scene);
        avatarMesh.add(object.scene);
      }
    }, xhr => {}, err => {
      console.warn(err);
    });
    scene.add(avatarMesh);
    avatarMeshes.push(avatarMesh);

    peerConnection.open = true;

    if (landState) {
      // emit owned xr-iframes

      const landXrIframe = root.childNodes[0];
      const ownedXrIframes = _getOwnedXrIframes(landXrIframe);
      let state = parse5.parseFragment(`<xr-site>${ownedXrIframes.map(xrIframe => xrIframe.outerHTML).join('')}</xr-site>`);
      state = _normalizeEl(state);
      sendChannel.send(JSON.stringify({
        method: 'initState',
        state,
      }));
    }

    pingInterval = setInterval(() => {
      sendChannel.send(JSON.stringify({
        method: 'ping',
      }));
    }, 1000);

    updateInterval = setInterval(() => {
      const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
      const gamepads = navigator.getGamepads().slice(0, 2);

      sendChannel.send(JSON.stringify({
        method: 'pose',
        hmd: {
          position: c.position.toArray(),
          quaternion: c.quaternion.toArray(),
        },
        gamepads: gamepads.map(gamepad => {
          if (gamepad) {
            return {
              position: Array.from(gamepad.pose.position),
              quaternion: Array.from(gamepad.pose.orientation),
              visible: true,
            };
          } else {
            return {
              visible: false,
            };
          }
        }),
      }));
    }, 20);
  };
  sendChannel.onclose = () => {
    // console.log('data channel local close');

    _cleanup();
  };
  sendChannel.onerror = err => {
    // console.log('data channel local error', err);
  };
  let watchdogTimeout = 0;
  const _kick = () => {
    if (watchdogTimeout) {
      clearTimeout(watchdogTimeout);
      watchdogTimeout = 0;
    }
    watchdogTimeout = setTimeout(() => {
      peerConnection.close();
    }, 5000);
  };
  _kick();
  peerConnection.ondatachannel = e => {
    const {channel} = e;
    // console.log('data channel remote open', channel);
    channel.onclose = () => {
      // console.log('data channel remote close');
      peerConnection.close();
    };
    channel.onerror = err => {
      // console.log('data channel remote error', err);
    };
    channel.onmessage = e => {
      // console.log('data channel message', e.data);

      const data = JSON.parse(e.data);
      const {method} = data;
      if (method === 'pose') {
        if (avatarMesh && avatarMesh.riggedModel) {
          const {hmd, gamepads} = data;
          avatarMesh.riggedModel.setState(hmd, gamepads);
        }
      } else if (landState && method === 'initState') {
        const {state} = data;
        const stateXrSite = state.childNodes.find(node => node.tagName === 'xr-site');
        const stateXrIframes = stateXrSite ? stateXrSite.childNodes.filter(node => node.tagName === 'xr-iframe') : [];

        for (let i = 0; i < stateXrIframes.length; i++) {
          const xrIframe = document.createElement('xr-iframe');
          root.appendChild(xrIframe);
          const htmlString = parse5.serialize(state);
          xrIframe.outerHTML = htmlString;
        }
      } else if (landState && method === 'editState') {
        _applyEditState(data.spec);
      } else if (method === 'ping') {
        // nothing
      } else {
        console.warn('unknown method', {method});
      }

      _kick();
    };
    peerConnection.recvChannel = channel;
  };
  peerConnection.close = (close => function() {
    _cleanup();

    return close.apply(this, arguments);
  })(peerConnection.close);
  const _cleanup = () => {
    if (peerConnection.open) {
      peerConnection.open = false;
    }
    if (pingInterval) {
      clearInterval(pingInterval);
      pingInterval = 0;
    }
    if (updateInterval) {
      clearInterval(updateInterval);
      updateInterval = 0;
    }
    const index = peerConnections.indexOf(peerConnection);
    if (index !== -1) {
      peerConnections.splice(index, 1);
    }
    if (avatarMesh) {
      scene.remove(avatarMesh);
      avatarMeshes.splice(avatarMeshes.indexOf(avatarMesh), 1);
      avatarMesh = null;
    }
    if (landState) {
      // remove owned xr-iframes

      const ownedXrIframes = Array.from(root.querySelectorAll('xr-iframe')).filter(xrIframe => /^owned:/.test(xrIframe.id));
      for (let i = 0; i < ownedXrIframes.length; i++) {
        const ownedXrIframe = ownedXrIframes[i];
        const match = ownedXrIframe.id.match(/^owned:(.*?)-/);
        if (match) {
          const ownerId = match[1];
          if (ownerId === peerConnectionId) {
            ownedXrIframe.parentNode.removeChild(ownedXrIframe);
          }
        }
      }
    }
  };
  peerConnection.connectionId = peerConnectionId;
  peerConnection.open = false;

  return peerConnection;
};
const _applyEditState = spec => {
  const {method, keyPath, key, value, values} = spec;
  const el = _findElByKeyPath(root, keyPath.slice(1));
  if (el) {
    switch (method) {
      case 'setAttributes': {
        for (let i = 0; i < values.length; i++) {
          const {key, value} = values[i];
          (el.setAttributeRaw || el.setAttribute).call(el, key, value);
        }
        break;
      }
      case 'setAttribute': {
        (el.setAttributeRaw || el.setAttribute).call(el, key, value);
        break;
      }
      case 'removeAttribute': {
        el.removeAttribute(key);
        break;
      }
      case 'appendChild': {
        const childNode = el.childNodes[key];
        const newNode = _parseHtml(value);
        el.insertBefore(newNode, childNode);
        break;
      }
      case 'removeChild': {
        let match, childNode;
        if (typeof key === 'number' && key < el.childNodes.length) {
          childNode = el.childNodes[key];
          el.removeChild(childNode);
        } else if (
          typeof key === 'string' &&
          (match = key.match(/^#(.+)$/)) &&
          (childNode = Array.from(el.childNodes).find(node => node.id === match[1]))
        ) {
          el.removeChild(childNode);
        } else {
          console.warn('remove missing child', keyPath, key);
        }
        break;
      }
    }
  } else {
    console.warn('could not find element for key path', keyPath);
  }
};

let rtcWs = null;
const connectionId = _randomString();
const peerConnections = [];
const _rtcConnect = (type, userName, channelName, onInitState) => {
  rtcWs = new WebSocket(`${LAMBDA_URLS.presenceWs}?u=${encodeURIComponent(userName)}&c=${encodeURIComponent(channelName)}`);
  rtcWs.onopen = () => {
    // console.log('presence socket open');

    rtcWs.send(JSON.stringify({
      method: 'init',
      connectionId,
    }));
  };
  const _addPeerConnection = peerConnectionId => {
    let peerConnection = peerConnections.find(peerConnection => peerConnection.connectionId === peerConnectionId);
    if (peerConnection && !peerConnection.open) {
      peerConnection.close();
      peerConnection = null;
    }
    if (!peerConnection) {
      peerConnection = _makePeerConnection(peerConnectionId);
      peerConnection.onicecandidate = e => {
        // console.log('ice candidate', e.candidate);

        rtcWs.send(JSON.stringify({
          dst: peerConnectionId,
          src: connectionId,
          method: 'iceCandidate',
          candidate: e.candidate,
        }));
      };
      peerConnections.push(peerConnection);

      if (connectionId < peerConnectionId) {
        peerConnection
          .createOffer()
          .then(offer => {
            peerConnection.setLocalDescription(offer);

            rtcWs.send(JSON.stringify({
              dst: peerConnectionId,
              src: connectionId,
              method: 'offer',
              offer,
            }));
          });
      }
    }
  };
  const _removePeerConnection = peerConnectionId => {
    const index = peerConnections.findIndex(peerConnection => peerConnection.connectionId === peerConnectionId);
    if (index !== -1) {
      peerConnections.splice(index, 1)[0].close();
    } else {
      console.warn('no such peer connection', peerConnectionId, peerConnections.map(peerConnection => peerConnection.connectionId));
    }
  };
  rtcWs.onmessage = e => {
    // console.log('got message', e.data);

    const data = JSON.parse(e.data);
    const {method} = data;
    if (method === 'join') {
      const {connectionId: peerConnectionId} = data;
      _addPeerConnection(peerConnectionId);
    } else if (method === 'offer') {
      const {src: peerConnectionId, offer} = data;

      const peerConnection = peerConnections.find(peerConnection => peerConnection.connectionId === peerConnectionId);
      if (peerConnection) {
        peerConnection.setRemoteDescription(offer)
          .then(() => peerConnection.createAnswer())
          .then(answer => {
            peerConnection.setLocalDescription(answer);

            rtcWs.send(JSON.stringify({
              dst: peerConnectionId,
              src: connectionId,
              method: 'answer',
              answer,
            }));
          });
      } else {
        console.warn('no such peer connection', peerConnectionId, peerConnections.map(peerConnection => peerConnection.connectionId));
      }
    } else if (method === 'answer') {
      const {src: peerConnectionId, answer} = data;

      const peerConnection = peerConnections.find(peerConnection => peerConnection.connectionId === peerConnectionId);
      if (peerConnection) {
        peerConnection.setRemoteDescription(answer);
      } else {
        console.warn('no such peer connection', peerConnectionId, peerConnections.map(peerConnection => peerConnection.connectionId));
      }
    } else if (method === 'iceCandidate') {
      const {src: peerConnectionId, candidate} = data;

      const peerConnection = peerConnections.find(peerConnection => peerConnection.connectionId === peerConnectionId);
      if (peerConnection) {
        peerConnection.addIceCandidate(candidate)
          .catch(err => {
            // console.warn(err);
          });
      } else {
        console.warn('no such peer connection', peerConnectionId, peerConnections.map(peerConnection => peerConnection.connectionId));
      }
    } else if (method === 'leave') {
      const {connectionId: peerConnectionId} = data;
      _removePeerConnection(peerConnectionId);
    } else if (method === 'initState') {
      const {state} = data;
      onInitState(state);
    } else if (method === 'editState') {
      _applyEditState(data.spec);
    }
  };
  rtcWs.onclose = () => {
    clearInterval(pingInterval);
    console.log('rtc closed');
  };
  rtcWs.onerror = err => {
    console.warn('rtc error', err);
    clearInterval(pingInterval);
  };
  rtcWs.type = type;
  rtcWs.userName = userName;
  rtcWs.channelName = channelName;
  rtcWs.pushScene = () => {
    const html = root.getHTML();
    rtcWs.send(JSON.stringify({
      method: 'setHtml',
      html,
    }));
  };
  rtcWs.pushAssets = () => {
    const landXrIframe = root.childNodes[0];
    const extentXrIframes = _getUnownedXrIframes(landXrIframe);
    const assetXrIframes = extentXrIframes.map(extentXrIframe => _getUnownedXrIframes(extentXrIframe)).flat();
    const html = `<xr-site>\n${assetXrIframes.filter(xrIframe => !!xrIframe.id).map(xrIframe => '  ' + xrIframe.outerHTML).join('\n')}\n</xr-site>\n`;
    rtcWs.send(JSON.stringify({
      method: 'setInitialHtml',
      html,
    }));
  };
  const pingInterval = setInterval(() => {
    rtcWs.send(JSON.stringify({
      method: 'ping',
    }));
  }, 30*1000);
};
const _rtcDisconnect = () => {
  if (rtcWs) {
    rtcWs.close();
    rtcWs = null;
  }
  for (let i = 0; i < peerConnections[i]; i++) {
    peerConnections[i].close();
  }
  peerConnections.length = 0;
};

let defaultGltf = new THREE.Object3D();
defaultGltf.visible = false;
window.addEventListener('message', e => {
  const {data} = e;
  const {method} = data;
  switch (method) {
    case 'login': {
      loginToken = data.loginToken;
      console.log('app login', loginToken);

      const isLoggedIn = !!loginToken;
      defaultGltf.visible = isLoggedIn;
      if (orbitControls) {
        orbitControls.enabled = isLoggedIn;
      }

      if (isLoggedIn) {
        loginPromise.resolve();
      }

      break;
    }
    case 'enter2d': {
      _enter2d();
      break;
    }
    case 'loadScene': {
      const {html} = data;
      if (html) {
        root.setHTML(html);
      } else {
        root.innerHTML = '';
      }
      rtcWs && rtcWs.pushScene();
      break;
    }
    case 'joinChannel': {
      const {userName, channelName} = data;
      _rtcConnect('channel', loginToken.name, `${userName}/${channelName}`, state => {
        const htmlString = parse5.serialize(state);
        root.setHTML(htmlString);
      });
      break;
    }
  }
});
window.addEventListener('paste', e => {
  if (keyboardFocus && e.clipboardData.items.length > 0) {
    e.clipboardData.items[0].getAsString(pasteString => {
      pasteString = pasteString.slice(0, 1024);
      const s = keyboardFocus.textMesh.getText();
      const index = keyboardFocus.caretMesh.getValue();
      keyboardFocus.textMesh.setText(s.slice(0, index) + pasteString + s.slice(index));
      keyboardFocus.caretMesh.setValue(index + pasteString.length);
    });
  }
});

/* localforage.config({driver: localforage.INDEXEDDB});
const chunkSize = 100 * 1024 * 1024;
localforage.write = (p, d) => new Promise((accept, reject) => {
  console.log('write', p, d);
  const _recurse = (startIndex = 0, index = 0) => {
    if (startIndex < d.length) {
      const slice = d.slice(startIndex, startIndex + chunkSize);

      console.log('set item', p + '-' + index);
      localforage.setItem(p + '-' + index, slice, err => {
        if (!err) {
          startIndex += slice.length;
          index++;
          _recurse(startIndex, index);
        } else {
          reject(err);
        }
      });
    } else {
      localforage.removeItem(p + '-' + index, err => {
        if (!err) {
          accept();
        } else {
          reject(err);
        }
      });
    }
  };
  _recurse();
});
localforage.read = p => new Promise((accept, reject) => {
  const result = [];
  const _recurse = (index = 0) => {
    console.log('get item', p + '-' + index);
    localforage.getItem(p + '-' + index, (err, data) => {
      if (!err) {
        if (data) {
          result.push(data);

          index++;
          _recurse(index);
        } else {
          accept(result);
        }
      } else {
        reject(err);
      }
    });
  };
  _recurse();
}); */

// helpers

const _getFrontOfCamera = () => {
  const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
  localQuaternion.copy(vrCamera.quaternion);
  localVector
    .copy(vrCamera.position)
    .add(
      localVector2.set(0, 0, -1)
        .applyQuaternion(localQuaternion)
    );
  localVector2.set(1, 1, 1);

  return {
    position: localVector.clone(),
    quaternion: localQuaternion.clone(),
    scale: localVector2.clone(),
  };
};
const _insertBefore = (a, b) => {
  scene.add(a);
  const aIndex = scene.children.indexOf(a);
  scene.children.splice(aIndex, 1);
  const bIndex = scene.children.indexOf(b);
  scene.children.splice(bIndex, 0, a);
};

// main

const scene = new THREE.Scene();
// scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0xFFFFFF);
scene.matrixAutoUpdate = false;

/* const cubeMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
  const material = new THREE.MeshPhongMaterial({
    color: 0xab47bc,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z = -5;
  mesh.rotation.order = 'YXZ';
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(cubeMesh); */

const skyboxMesh = (() => {
  const radius = 99;
  const timeFactor = 1000;
  const geometry = new THREE.SphereBufferGeometry(radius, 32, 32)
    .applyMatrix(new THREE.Matrix4().makeScale(-1, -1, -1));
  const skyboxVsh = `
    // uniform float uAnimation;
    varying vec3 vPosition;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vPosition = position;
      vUv = uv;
    }
  `;
  const skyboxFsh = `
    uniform float uAnimation;
    varying vec3 vPosition;
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(uAnimation);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: skyboxVsh,
    fragmentShader: skyboxFsh,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    material.uniforms.uTime.value = (Date.now() % timeFactor) / timeFactor;
  };
  return mesh;
})();
if (!/helio/i.test(navigator.userAgent)) {
  scene.add(skyboxMesh);
}

const floorMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(300, 300, 300, 300)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
    // .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
  const floorVsh = `
    uniform float uAnimation;
    // attribute float scene;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      float radius = sqrt(position.x*position.x + position.z*position.z);
      // vec3 p = vec3(position.x, position.y - (1.0 - uAnimation * radius), position.z);
      vec3 p = vec3(position.x, position.y - (1.0 - uAnimation) * radius, position.z);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
      vPosition = position;
      // vScene = scene;
      vDepth = gl_Position.z / 200.0;
    }
  `;
  const floorFsh = `
    uniform float uAnimation;
    // uniform sampler2D uTex;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      vec3 c;
      float a;
      c = vec3(0.8 + vDepth);
      /* vec2 uv = floor(vPosition + 150).xz / 300.0;
      c = texture2D(uTex, uv).rgb; */
      vec3 f = fract(vPosition);
      if (f.x <= 0.01 || f.x >= 0.99 || f.z <= 0.01 || f.z >= 0.99) {
        // a = 0.0;
        discard;
      } else {
        a = uAnimation*0.5;
      }
      gl_FragColor = vec4(c, a);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      /* uTex: {
        type: 't',
        value: new THREE.Texture(),
      }, */
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3());
  mesh.intersect = ray => {
    const point = ray.origin.y !== 0 ? ray.intersectPlane(mesh.plane, localVector) : null;
    if (point) {
      const distance = ray.origin.distanceTo(point);
      if (distance < 10) {
        const {x, z: y} = point;
        return {
          type: 'floor',
          mesh,
          point,
          distance,
          cancel: false,
          x,
          y,
        };
      } else {
        return null;
      }
    } else {
      return null;
    }
  };
  /* worker.request({
    method: 'getBiomeColors',
    x: 0,
    z: 0,
  })
    .then(res => {
      console.log('got colors', res);
      const canvas2d = document.createElement('canvas');
      const ctx = canvas2d.getContext('2d');
      const imageData = ctx.createImageData(300, 300);
      const numColors = res.colors.length / 3;
      for (let i = 0; i < numColors; i++) {
        imageData.data[i*4] = res.colors[i*3];
        imageData.data[i*4+1] = res.colors[i*3+1];
        imageData.data[i*4+2] = res.colors[i*3+2];
        imageData.data[i*4+3] = 1;
      }
      material.uniforms.uTex.value.image = imageData;
      material.uniforms.uTex.value.needsUpdate = true;
    }); */
  return mesh;
})();
if (!/helio/i.test(navigator.userAgent)) {
  scene.add(floorMesh);
}

const [
  keyboardImg,
  uiIframe,
  interfaceHtml,
  labelHtml,
  backpackImgBase64,
  searchSitesJson,
  keyboardHighlightCanvasCtx,
  keyMap,
  fontJson,
  fontTexture,
] = await Promise.all(
  [
    'keyboard.png',
  ].map(src => new Promise((accept, reject) => {
    const img = new Image();
    img.onload = () => {
      accept(img);
    };
    img.onerror = err => {
      reject(err);
    };
    img.crossOrigin = 'Anonymous';
    img.src = src;
  }))
  .concat([
    new Promise((accept, reject) => {
      const iframe = document.createElement('iframe');
      iframe.src = 'https://render.exokit.xyz/';
      // iframe.src = './exokit-render/index.html';
      iframe.onload = () => {
        accept(iframe);
      };
      iframe.onerror = reject;
      iframe.style.position = 'absolute';
      iframe.style.top = '-4096px';
      iframe.style.left = '-4096px';
      document.body.appendChild(iframe);
    }),
    fetch('interface.html').then(res => res.text()),
    fetch('label.html').then(res => res.text()),
    fetch('backpack.png').then(res => res.blob()).then(blob => new Promise((accept, reject) => {
      const reader = new FileReader();
      reader.onerror = reject;
      reader.onload = () => {
        accept(reader.result);
      };
      reader.readAsDataURL(blob);
    })),
    fetch('sites.json')
      .then(res => res.json())
      .then(sitesJson => {
        return s => {
          const maxResults = 12;
          if (s) {
            const regexps = s.split(/\s/).filter(s => !!s).map(s => new RegExp(escapeRegExp(s), 'i'));
            const results = [];
            for (let i = 0; i < sitesJson.length; i++) {
              const site = sitesJson[i];
              if (regexps.some(regexp => regexp.test(site.label) || regexp.test(site.url))) {
                results.push(site);
                if (results.length >= maxResults) {
                  break;
                }
              }
            }
            return results;
          } else {
            return sitesJson.slice(0, maxResults);
          }
        };
      }),
    new Promise((accept, reject) => {
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = 'keyboard-highlight.png';
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        accept(ctx);
      };
      img.onerror = err => {
        reject(err);
      };
    }),
    fetch('keyboard.svg')
      .then(res => res.text())
      .then(keyboardText => {
        const result = [];

        const div = document.createElement('div');
        div.innerHTML = keyboardText;
        const keyEls = div.querySelectorAll('svg > g[key]');
        for (let i = 0; i < keyEls.length; i++) {
          const keyEl = keyEls[i];
          const key = keyEl.getAttribute('key');
          const shapeEl = keyEl.children[0];
          const boundings = svgBoundings[shapeEl.tagName.toLowerCase()](shapeEl);
          const {
            left,
            right,
            top,
            bottom,
          } = boundings;
          const x1 = left * keyboardMatrix[0];
          const x2 = right * keyboardMatrix[0];
          const y1 = top * keyboardMatrix[1];
          const y2 = bottom * keyboardMatrix[1];
          result.push([key, x1, y1, x2, y2]);
        }

        return Promise.resolve(result);
      }),
      fetch('DejaVu-sdf.json').then(res => res.json()),
      new Promise((accept, reject ) => {
        new THREE.TextureLoader().load('DejaVu-sdf.png', accept);
      }),
  ]),
);

const _makeTextMesh = (s = '', color = 0x000000, size = 1) => {
  // create a geometry of packed bitmap glyphs,
  // word wrapped to 300px and right-aligned
  var geometry = createTextGeometry({
    width: Infinity,
    font: fontJson,
  });

  // change text and other options as desired
  // the options sepcified in constructor will
  // be used as defaults
  geometry.update(s);

  // the resulting layout has metrics and bounds
  // console.log(geometry.layout.height)
  // console.log(geometry.layout.descender)

  var material = new THREE.RawShaderMaterial(createSDFShader({
    map: fontTexture,
    transparent: true,
    color,
    // color: palette[Math.floor(Math.random() * palette.length)]
    // negate: false,
    side: THREE.DoubleSide,
  }));

  const scaleFactor = 0.002 * size;

  const mesh = new THREE.Mesh(geometry, material)
  mesh.position.set(0, -geometry.layout.lineHeight * 0.001, 0);
  mesh.scale.set(scaleFactor, -scaleFactor, -scaleFactor);
  mesh.getText = () => s;
  mesh.setText = newS => {
    if (newS !== s) {
      s = newS;
      geometry.update(s);
    }
  };
  return mesh;
};

const _makeCaretMesh = (labelMesh, color = 0x000000) => {
  const geometry = new THREE.PlaneBufferGeometry(0.005, 0.1)
    .applyMatrix(new THREE.Matrix4().makeTranslation(-labelMesh.width/2, 0, 0));
  const material = new THREE.MeshBasicMaterial({
    color,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z += 0.001;
  mesh.visible = false;
  mesh.frustumCulled = false;
  mesh.getValue = () => value;
  mesh.setValue = newValue => {
    value = newValue;

    const glyphs = labelMesh.getGlyphs();
    if (glyphs.length > 0) {
      if (value < glyphs.length) {
        mesh.position.x = glyphs[value].x * labelMesh.textMesh.scale.x;
      } else {
        mesh.position.x = glyphs[glyphs.length - 1].x * labelMesh.textMesh.scale.x;
      }
    } else {
      mesh.position.x = 0;
    }
  };
  return mesh;
};

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.y = 1.6;

const cameraRig = new THREE.Object3D();
cameraRig.add(camera);
scene.add(cameraRig);

const renderer = new THREE.WebGLRenderer({
  // canvas: document.getElementById('canvas'),
  // alpha: true,
  antialias: true,
});
console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.domElement.ondrop = dropHandler;
renderer.domElement.ondragover = dragOverHandler;
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

function dropHandler(ev) {
  ev.preventDefault();

  for (var i = 0; i < ev.dataTransfer.items.length; i++) {
    if (ev.dataTransfer.items[i].kind === 'file') {
      var file = ev.dataTransfer.items[i].getAsFile();

      console.log(`file ${i}: ${file.name} ${file.type}`);

      const _loadModel = u => {
        _addNewApp(u, faviconImg, 'model', -1);
      };
      const _loadLocal = () => {
        console.log('loading', file.name);
        const reader = new FileReader();
        reader.onload = async e => {
          let data = new Uint8Array(reader.result, 0, reader.result.byteLength);
          const d = '/lol';
          const p = `${d}/${file.name}`;
          console.log('writing', p, data.byteLength);
          await localforage.write(p, data);
          data = null;
          data = await localforage.read(p);
          console.log('got file', data.map(data => data.length));
          const u = URL.createObjectURL(new Blob(data, {
            type: 'application/octet-stream',
          }));
          _loadModel(u);
        };
        reader.readAsArrayBuffer(file);
      };
      const _loadRemote = () => {
        const postfix = _randomString();
        const u = `${LAMBDA_URLS.token}?email=${encodeURIComponent(loginToken.email)}&token=${encodeURIComponent(loginToken.token)}&name=${encodeURIComponent(file.name + '-' + postfix)}&type=${encodeURIComponent(file.type)}`;

        fetch(u, {
          method: 'POST',
          /* headers: {
            'Content-Type': file.type,
          }, */
        })
          .then(res => {
            if (res.status >= 200 && res.status < 300) {
              return res.json();
            } else {
              throw new Error(`invalid status code: ${res.status}`);
            }
          })
          .then(j => {
            const tokenId = j && j.tokenId;
            const name = j && j.name;
            const url = j && j.url;
            const uploadUrl = j && j.uploadUrl;
            console.log('got token', {tokenId, name, url, uploadUrl});

            return fetch(uploadUrl, {
              method: 'PUT',
              body: file,
              mode: 'cors',
            })
            .then(res => res.blob())
            .then(() => _loadModel(url));
          })
          .catch(err => {
            console.warn(err.stack);
          });
      };
      /* if (!_isInMultiverse()) {
        _loadLocal();
      } else { */
        _loadRemote();
      // }
    }
  }
}
function dragOverHandler(ev) {
  ev.preventDefault();
}

const layers = [renderer.domElement];

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

/* const pointerMesh = (() => {
  const targetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.5)),
  ]).applyMatrix(new THREE.Matrix4().makeScale(0.05, 0.05, 0.05));
  const targetVsh = `
    uniform vec3 worldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position + worldPos, 1.);
    }
  `;
  const targetFsh = `
    uniform float uTime;
    void main() {
      gl_FragColor = vec4(vec3(min(pow(uTime, 0.5), 0.9)), 1.0);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      worldPos: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: targetVsh,
    fragmentShader: targetFsh,
    // transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  // mesh.visible = false;
  return mesh;
})();
scene.add(pointerMesh); */

/* const targetMesh = (() => {
  const targetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.5)),
  ]).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
  const targetVsh = `
    uniform vec3 worldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position + worldPos, 1.);
    }
  `;
  const targetFsh = `
    uniform float uTime;
    void main() {
      gl_FragColor = vec4(vec3(max(1.0 - pow(uTime, 0.5), 0.1)), 1.0);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      worldPos: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: targetVsh,
    fragmentShader: targetFsh,
    // transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.visible = false;
  return mesh;
})();
scene.add(targetMesh); */

// events

const _addOrbitControls = () => {
  const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
  orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement);
  orbitCamera.position.copy(fakeXrDisplay.position);
  orbitCamera.quaternion.copy(fakeXrDisplay.quaternion);
  scene.add(orbitCamera);
  orbitCamera.updateMatrixWorld();
  orbitControls.target.copy(orbitCamera.position).add(new THREE.Vector3(0, 0, -1).applyQuaternion(orbitCamera.quaternion));
  orbitControls.screenSpacePanning = true;
  orbitControls.enabled = !!loginToken;
  orbitControls.enableMiddleZoom = false;
  orbitControls.update();
};
const _removeOrbitControls = () => {
  scene.remove(orbitControls.object);
  orbitControls.dispose();
  orbitControls = null;
};

const _mousedown = e => {
  if (loginToken) {
    const gamepads = navigator.getGamepads();
    const gamepad = gamepads[1];
    if (gamepad) {
      if (e.button === 0) {
        gamepad.buttons[1].pressed = true;
      } else if (e.button === 1) {
        gamepad.buttons[0].pressed = true;
      } else if (e.button === 2) {
        gamepad.buttons[2].pressed = true;
      }
    }
    if (!window.document.pointerLockElement && (intersectionSpecs[1] || moveSpecs[1])) {
      if (orbitControls && ((intersectionSpecs[1] && intersectionSpecs[1].cancel) || moveSpecs[1])) {
        _removeOrbitControls();
      }
    }
  }
};
const _mouseup = e => {
  if (loginToken) {
    const gamepads = navigator.getGamepads();
    const gamepad = gamepads[1];
    if (gamepad) {
      if (e.button === 0) {
        gamepad.buttons[1].pressed = false;
      } else if (e.button === 1) {
        gamepad.buttons[0].pressed = false;
      } else if (e.button === 2) {
        gamepad.buttons[2].pressed = false;
      }
    }

    if (!window.document.pointerLockElement) {
      _addOrbitControls();
    }
  }
};

let unbindEvents = null;
const _bindEventTarget = target => {
  if (unbindEvents) {
    unbindEvents();
    unbindEvents = null;
  }

  const _bindEvents = (windowEvents = {}, documentEvents = {}) => {
    for (const k in windowEvents) {
      const fn = windowEvents[k];
      window.addEventListener(k, fn);
    }
    for (const k in documentEvents) {
      const fn = documentEvents[k];
      document.addEventListener(k, fn);
    }

    unbindEvents = () => {
      for (const k in windowEvents) {
        const fn = windowEvents[k];
        window.removeEventListener(k, fn);
      }
      for (const k in documentEvents) {
        const fn = documentEvents[k];
        document.removeEventListener(k, fn);
      }
    };
  };
  if (target === 'ui') {
    /* const _addTransformControls = (camera, iframe) => {
      transformControls = new THREE.TransformControls(camera, document.body, viewport);
      transformControls.iframe = iframe;

      transformControls.addEventListener('dragging-changed', e => {
        orbitControls.enabled = !e.value;
      });
      transformControls.addEventListener('change', e => {
        iframe.position = mesh.position.toArray();
        iframe.orientation = mesh.quaternion.toArray();
        iframe.scale = mesh.scale.toArray();
      });

      const mesh = new THREE.Object3D();
      mesh.position.fromArray(_parseVector(iframe.position));
      mesh.quaternion.fromArray(_parseVector(iframe.orientation));
      mesh.scale.fromArray(_parseVector(iframe.scale));
      scene.add(mesh);
      mesh.updateMatrixWorld();

      transformControls.attach(mesh);
      scene.add(transformControls);
    };
    const _removeTransformControls = () => {
      scene.remove(transformControls.object);
      scene.remove(transformControls);
      transformControls.dispose();
      transformControls = null;
    }; */

    _bindEvents({
      mousemove(e) {
        if (fakeXrDisplay) {
          localCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
          localCamera.matrixWorld.getInverse(localCamera.matrixWorldInverse);
          localCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
          localCamera.projectionMatrixInverse.getInverse(localCamera.projectionMatrix);

          const rect = renderer.domElement.getBoundingClientRect();
          let xFactor = (e.clientX - rect.left) / rect.width;
          if (fakeXrDisplay.stereo) {
            xFactor = (xFactor % 0.5) * 2;
          }
          const yFactor = -(e.clientY - rect.top) / rect.height;
          localVector2D.set(xFactor * 2 - 1, yFactor * 2 + 1);
          localRaycaster.setFromCamera(localVector2D, localCamera);

          // console.log('set mouse', localVector2D.toArray(), localRaycaster.ray.origin.toArray(), localRaycaster.ray.direction.toArray());
          mouse.quaternion.setFromRotationMatrix(
            localMatrix.lookAt(
              localRaycaster.ray.origin,
              localVector.copy(localRaycaster.ray.origin).add(localRaycaster.ray.direction),
              localVector2.set(0, 1, 0)
            )
          );
          mouse.position.copy(localRaycaster.ray.origin).add(localVector.set(0, 0, -0.5).applyQuaternion(mouse.quaternion));
        }
      },
      /* mousemove(e) {
        const localCamera = camera;
        localCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
        localCamera.matrixWorld.getInverse(localCamera.matrixWorldInverse);
        localCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
        localCamera.projectionMatrixInverse.getInverse(localCamera.projectionMatrix);

        localCamera.matrixWorld.decompose(localCamera.position, localCamera.quaternion, localCamera.scale);
        const rect = document.body.getBoundingClientRect();
        localRaycaster.setFromCamera(
          localVector2D.set(
            ((e.clientX / rect.width) % 0.5 * 2) * 2 - 1,
            (-e.clientY / rect.height) * 2 + 1
          ),
          localCamera
        );
        const line = localLine.set(
          localRaycaster.ray.origin,
          localVector.copy(localRaycaster.ray.origin)
            .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(100))
        );
        const distanceSpecs = layers.map(layer => {
          if (layer.tagName === 'IFRAME') {
            line.closestPointToPoint(localVector.fromArray(_parseVector(layer.position)), true, localVector2);
            const distance = localVector.distanceTo(localVector2);
            if (distance < 1) {
              return {
                iframe: layer,
                distance,
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        }).filter(spec => !!spec).sort((a, b) => a.distance - b.distance);
        const closestIframe = distanceSpecs.length > 0 ? distanceSpecs[0].iframe : null;
        const shouldTransform = (!!transformControls && transformControls.dragging) || !!closestIframe;
        if (shouldTransform && (!transformControls || (transformControls.iframe !== closestIframe && !transformControls.dragging))) {
          if (transformControls) {
            _removeTransformControls();
          }

          _addTransformControls(localCamera, closestIframe);
        } else if (!shouldTransform && transformControls) {
          _removeTransformControls();
        }
      }, */
      keydown(e) {
        if (loginToken) {
          if (keyboardFocus) {
            _handleKey(e.keyCode, e.shiftKey, e.ctrlKey);
          } else {
            switch (e.which) {
              case 9: { // tab
                e.preventDefault();

                const gamepads = navigator.getGamepads();
                if (gamepads[1]) {
                  gamepads[1].buttons[5].pressed = true;
                }
                break;
              }
              /* case 70: { // F
                const gamepads = navigator.getGamepads();
                if (gamepads[1]) {
                  gamepads[1].buttons[2].pressed = true;
                }
                break;
              } */
              case 46: { // del
                for (let i = 0; i < currentMoveMeshes.length; i++) {
                  const moveMesh = currentMoveMeshes[i];
                  if (moveMesh) {
                    const {xrIframe} = moveMesh;

                    if (rtcWs) {
                      const index = _getChildNodeIndex(xrIframe);
                      const m = {
                        method: 'editState',
                        spec: {
                          keyPath: [0],
                          method: 'removeChild',
                          key: landState ? ('#' + xrIframe.id) : index,
                        },
                      };
                      if (landState) {
                        for (let i = 0; i < peerConnections.length; i++) {
                          const peerConnection = peerConnections[i];
                          peerConnection.sendChannel && peerConnection.sendChannel.send(JSON.stringify(m));
                        }
                      } else {
                        rtcWs.send(JSON.stringify(m));
                      }
                    }

                    root.removeChild(xrIframe);
                    currentMoveMeshes[i] = null;
                  }
                }
                break;
              }
            }
          }
        }
      },
      keyup(e) {
        if (!keyboardFocus) {
          switch (e.which) {
            case 9: { // tab
              e.preventDefault();

              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = false;
              }
              break;
            }
            /* case 70: { // F
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = false;
              }
              break;
            } */
          }
        }
      },
      mousedown: _mousedown,
      mouseup: _mouseup,
      dblclick(e) {
        if (loginToken && !(intersectionSpecs[1] && intersectionSpecs[1].cancel)) {
          _enter2d();
        }
      },
    }, {
      pointerlockchange(e) {
        if (window.document.pointerLockElement) {
          _bindEventTarget('xr');
        }
      },
    });

    _addOrbitControls();
    unbindEvents = (unbindEvents => function() {
      unbindEvents.apply(this, arguments);
      _removeOrbitControls();
    })(unbindEvents);
  } else if (target === 'xr') {
    _bindEvents({
      /* click(e) {
        renderer.domElement.requestPointerLock();
      }, */
      mousedown: _mousedown,
      mouseup: _mouseup,
      mousemove(e) {
        if (window.document.pointerLockElement) {
          const {movementX, movementY} = e;

          /* if (keys.ctrl) {
            const controllerOffset = controllerOffsets[controllerIndex];
            controllerOffset.x += movementX * 0.002;
            controllerOffset.y -= movementY * 0.002;
          } else if (keys.alt) {
            const controllerOffset = controllerOffsets[controllerIndex];
            controllerOffset.x += movementX * 0.002;
            controllerOffset.z += movementY * 0.002;
          } else { */
            localEuler.setFromQuaternion(fakeXrDisplay.quaternion, localEuler.order);
            localEuler.y -= movementX * 0.01;
            localEuler.x -= movementY * 0.01;
            localEuler.x = Math.min(Math.max(localEuler.x, -Math.PI/2), Math.PI/2);
            fakeXrDisplay.quaternion.setFromEuler(localEuler);

            fakeXrDisplay.pushUpdate();
          // }
        }
      },
      wheel(e) {
        if (window.document.pointerLockElement) {
          // rig.menuMesh.listMesh.updateWheel(e.deltaX/100, -e.deltaY/100);
        }
      },
      keydown(e) {
        // if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 83: { // S
              keys.down = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 65: { // A
              keys.left = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 68: { // D
              keys.right = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 9: { // tab
              e.preventDefault();

              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = true;
              }
              break;
            }
            /* case 70: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = true;
              }
              break;
            } */
            case 82: { // R
              keys.r = true;
              break;
            }
            case 70: { // F
              keys.f = true;
              break;
            }
            /* case 49: // 1
            case 50: // 2
            case 51: // 3
            case 52: // 4
            {
              toolMesh.setTool(e.which - 48);
              break;
            } */
          }
        // }
      },
      keyup(e) {
        // if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = false;
              break;
            }
            case 83: { // S
              keys.down = false;
              break;
            }
            case 65: { // A
              keys.left = false;
              break;
            }
            case 68: { // D
              keys.right = false;
              break;
            }
            case 9: { // tab
              e.preventDefault();

              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = false;
              }
              break;
            }
            /* case 70: { // F
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = false;
              }
              break;
            } */
            case 82: { // R
              keys.r = false;
              break;
            }
            case 70: { // F
              keys.f = false;
              break;
            }
          }
        /* } else {
          if (focusedTab && focusedTab.iframe) {
            focusedTab.iframe.sendKeyUp(e.which, {
              shiftKey: e.shiftKey,
              ctrlKey: e.ctrlKey,
              altKey: e.altKey,
            });
          }
        } */
      },
      /* keypress(e) {
        if (!window.document.pointerLockElement) {
          if (focusedTab) {
            // if (focusedTab === rig.menuMesh.urlMesh) {
            //   rig.menuMesh.urlMesh.handleKey(e.keyCode, e.shiftKey);
            // } else
            if (focusedTab.iframe) {
              focusedTab.iframe.sendKeyPress(e.which, {
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
              });
            }
          }
        }
      }, */
    }, {
      pointerlockchange(e) {
        if (!window.document.pointerLockElement) {
          _bindEventTarget('ui');
        }
      },
    });
  }
};

/* scenes.push({
  coords: [
    [0, 0],
  ],
  apps: [],
});
scenes.push({
  coords: [
    [-1, 0],
    [-2, 0],
    [-2, 1],
  ],
  apps: [],
}); */

// controller meshes

/* const controllerGeometry = new THREE.BoxBufferGeometry(0.05, 0.1, 0.01);
const controllerMaterial = new THREE.MeshPhongMaterial({
  color: 0x4caf50,
}); */
const controllerMeshes = Array(2);
for (let i = 0; i < controllerMeshes.length; i++) {
  const controllerMesh = new THREE.Object3D();
  controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 0, -0.1);
  controllerMesh.quaternion.setFromUnitVectors(
    new THREE.Vector3(0, 0, -1),
    new THREE.Vector3(0, -1, -1)
  );

  const rayMesh = (() => {
    const geometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
      .applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));
    const material = new THREE.MeshBasicMaterial({
      color: RAY_COLOR,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geometry, material);
    // mesh.visible = true;
    mesh.frustumCulled = false;
    return mesh;
  })();
  controllerMesh.add(rayMesh);
  controllerMesh.rayMesh = rayMesh;

  const dotMesh = (() => {
    const geometry = new THREE.SphereBufferGeometry(0.01, 5, 5);
    const material = new THREE.MeshBasicMaterial({
      color: 0xe91e63,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = -1;
    mesh.visible = true;
    return mesh;
  })();
  controllerMesh.add(dotMesh);
  controllerMesh.dotMesh = dotMesh;

  controllerMesh.ray = new THREE.Ray();
  controllerMesh.update = () => {
    controllerMesh.ray.origin.copy(controllerMesh.position);
    controllerMesh.ray.direction
      .set(0, 0, -1)
      .applyQuaternion(controllerMesh.quaternion);
  };

  cameraRig.add(controllerMesh);
  controllerMeshes[i] = controllerMesh;
}
// controllerMeshes[0].add(toolMesh);
const _getControllerIndex = gamepad => gamepad.hand === 'left' ? 0 : 1;

const teleportGeometry = new THREE.TorusBufferGeometry(0.5, 0.15, 3, 5)
  .applyMatrix(new THREE.Matrix4().makeRotationX(-(Math.PI / 2)))
  .applyMatrix(new THREE.Matrix4().makeRotationY((1 / 20) * (Math.PI * 2)));
const teleportMaterial = new THREE.MeshBasicMaterial({
  color: RAY_COLOR,
});
const _makeTeleportMesh = () => {
  const geometry = teleportGeometry;
  const material = teleportMaterial;

  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  mesh.frustumCulled = false;
  return mesh;
};
const teleportMeshes = [
  _makeTeleportMesh(),
  _makeTeleportMesh(),
];
scene.add(teleportMeshes[0]);
scene.add(teleportMeshes[1]);

// grid

let data;
const _loadData = () => {
  const _defaultData = () => ({
    tokenIds: 0,
    tokens: {},
    sceneIds: 0,
    scenes: {},
  });

  const s = localStorage.getItem('data');
  if (typeof s === 'string') {
    try {
      data = JSON.parse(s);
    } catch(err) {
      data = _defaultData();
    }
  } else {
    data = _defaultData();
  }
};
_loadData();
const _saveData = () => {
  localStorage.setItem('data', JSON.stringify(data));
};
const NULL_ADDRESS = '0x0000000000000000000000000000000000000000';
const ONE_ADDRESS  = '0x0000000000000000000000000000000000000001';
const _isInMultiverse = () => true; // trayMesh.mapMesh.minimapMesh.material.uniforms.uType.value === 1;
const _getUserAddress = () => _isInMultiverse() ? user.eth.defaultAccount : ONE_ADDRESS;
const _getShortUserAddress = () => {
  const match = _getUserAddress().match(/^(0x)[a-zA-Z0-9]{26}([a-zA-Z0-9]{14})$/);
  return match[1] + '...' + match[2];
};
const _getKey = (x, z) => [x, z].join(':');
const _getToken = async (x, z) => {
  if (_isInMultiverse()) {
    return await user.execute({
      method: 'getToken',
      data: {
        x,
        y: z,
      },
    });
  } else {
    const token = data.tokens[_getKey(x, z)] || {
      owner: NULL_ADDRESS,
      id: 0,
      x,
      y: z,
      lastTimestamp: 0,
    };
    token.scene = (() => {
      for (const k in data.scenes) {
        const scene = data.scenes[k];
        if (scene.coords.some(coord => coord[0] === x && coord[1] === z)) {
          return scene;
        }
      }
      return {
        id: 0,
        coords: [[x, z]],
        apps: [],
        owner: NULL_ADDRESS,
      };
    })();
    return token;
  }
};
const _setScene = async (coords, apps) => {
  if (_isInMultiverse()) {
    return await user.execute({
      method: 'setScene',
      data: {
        coords,
        apps,
      },
    });
  } else {
    const sceneId = ++data.sceneIds;
    for (let i = 0; i < coords.length; i++) {
      const [x, z] = coords[i];
      const key = _getKey(x, z);
      let token = data.tokens[key];
      if (!token) {
        token = data.tokens[key] = {
          owner: '0x000000000000000000000000000000000000000000',
          id: ++data.tokenIds,
          x,
          y: z,
          lastTimestamp: 0,
          sceneId: 0,
        };
      }
      if (token.sceneId) {
        const oldScene = data.scenes[token.sceneId];
        for (let j = 0; j < oldScene.coords.length; j++) {
          const oldCoord = oldScene.coords[j];
          const oldToken = (() => {
            for (const k in data.tokens) {
              const token = data.tokens[k];
              if (token.x === oldCoord[0] && token.y === oldCoord[1]) {
                return token;
              }
            }
            return null;
          })();
          if (oldToken) {
            oldToken.sceneId = 0;
          }
        }
        delete data.scenes[token.sceneId];
      }
      token.sceneId = sceneId;
    }
    const scene = {
      id: sceneId,
      coords,
      apps,
      owner: _getUserAddress(),
    };
    data.scenes[sceneId] = scene;
    _saveData();
    return sceneId;
  }
};
const _setSceneApps = async (sceneId, apps) => {
  if (_isInMultiverse()) {
    return await user.execute({
      method: 'setSceneApps',
      data: {
        sceneId,
        apps,
      },
    });
  } else {
    data.scenes[sceneId].apps = apps;
    _saveData();
  }
};
const _makeSceneObjectMesh = () => {
  const object = new THREE.Object3D();
  object.token = null;
  object.apps = [];
  object.update = () => {
    for (let i = 0; i < object.children.length; i++) {
      object.children[i].update();
    }
  };
  object.intersect = ray => {
    for (let i = 0; i < object.children.length; i++) {
      const intersection = object.children[i].intersect(ray);
      if (intersection) {
        return intersection;
      }
    }
    return null;
  };
  object.destroy = () => {
    for (let i = 0; i < object.children.length; i++) {
      object.children[i].destroy();
    }
    if (object.token === selectedSceneToken) {
      selectedSceneToken = null;

      lastSceneCoords[0] = NaN;
      lastSceneCoords[1] = NaN;
    }
    if (object.token === currentSceneToken) {
      currentSceneToken = null;

      lastSceneCoords[0] = NaN;
      lastSceneCoords[1] = NaN;
    }
    for (let i = 0; i < object.apps.length; i++) {
      const iconMesh = object.apps[i];
      _removeApp(iconMesh);
      _destroyApp(iconMesh);
    }
  };
  return object;
};
const _loadSceneMeshFromCoords = (x, z) => {
  const object = _makeSceneObjectMesh();
  object.token = {
    id: 0,
    coords: [[x, z]],
    apps: [],
    owner: NULL_ADDRESS,
  };
  /* _getToken(x, z)
    .then(token => {
      const {scene: sceneSpec, owner} = token;
      const _isValid = () => !sceneSpec.id || !sceneMeshes.some(sceneMesh => sceneMesh.token.id === sceneSpec.id);
      if (_isValid()) {
        object.token = sceneSpec;
        if (sceneSpec.id) {
          const {coords, apps} = sceneSpec;
          object.token.apps = []; // re-added below below

          for (let i = 0; i < apps.length; i++) {
            const app = apps[i];
            const {appType: type, url, position, orientation} = app;
            const iconMesh = _makeIconMesh(url, faviconImg, type, () => {
              selectedIconCoord.set(iconMesh.x, iconMesh.y);
              trayMesh.labelMesh.textMesh.setText(iconMesh.url);
            }, i => {
              _moveApp(iconMesh, i);
            }, () => {
              if (iconMesh.scene) {
                const index = iconMesh.scene.apps.indexOf(iconMesh);
                if (index !== -1) {
                  iconMesh.scene.token.apps.splice(index, 1);
                  // XXX save
                }
              }

              _removeApp(iconMesh);
              _destroyApp(iconMesh);
            }, true);
            // _addApp(iconMesh);
            iconMesh.moveMesh.position.fromArray(position);
            iconMesh.moveMesh.quaternion.fromArray(orientation);
            iconMesh.iframe.position = position;
            iconMesh.iframe.orientation = orientation;
            iconMesh.setSceneBindingRaw(object);
            console.log('load app', app, object.apps, object.token.apps);
          }
        }

        lastSceneCoords[0] = NaN;
        lastSceneCoords[1] = NaN;
      } else { // other scene beat us to it
        object.destroy();
        const index = sceneMeshes.indexOf(object);
        scene.remove(object);
        sceneMeshes.splice(sceneMeshes.indexOf(object), 1);
      }
    }); */
  return object;
};

const _makeLabelMesh = (label, type) => {
  const width = 2;
  const height = 2/8;
  const geometry = new THREE.PlaneBufferGeometry(width, height);

  let anchors = [];

  _renderLabel(label, type)
    .then(async result => {
      if (result.data) {
        texture.image = new ImageData(new Uint8ClampedArray(result.data.buffer, result.data.byteOffset, result.data.byteLength), uiSize, uiSize/8);
        texture.needsUpdate = true;

        anchors = result.anchors;
      }
    });
  const texture = new THREE.Texture(
    null,
    THREE.UVMapping,
    THREE.ClampToEdgeWrapping,
    THREE.ClampToEdgeWrapping,
    THREE.LinearFilter,
    THREE.LinearMipMapFilter,
    THREE.RGBAFormat,
    THREE.UnsignedByteType,
    16
  );
  const material = new THREE.MeshBasicMaterial({
    map: texture,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.plane = new THREE.Plane();
  mesh.leftLine = new THREE.Line3();
  mesh.topLine = new THREE.Line3();
  mesh.update = () => {
    mesh.leftLine.start
      .set(-width/2, -height/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.leftLine.end
      .set(-width/2, height/2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.topLine.start
      .set(-width/2, height/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.topLine.end
      .set(width/2, height/2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.plane.setFromCoplanarPoints(
      mesh.leftLine.start,
      mesh.leftLine.end,
      mesh.topLine.end
    );
  };
  mesh.intersect = ray => {
    const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
    if (intersectionPoint) {
      const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
      const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

      const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / width;
      const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / height;
      const distance = ray.origin.distanceTo(intersectionPoint);

      if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
        const x = Math.floor(xFactor * uiSize);
        const y = Math.floor(yFactor * uiSize/8);
        const anchor = anchors.find(anchor => x >= anchor.left && x <= anchor.right && y >= anchor.top && y <= anchor.bottom) || null;

        if (anchor) {
          return {
            type: 'label-mesh',
            distance,
            cancel: true,
            id: anchor.id,
            labelMesh: mesh,
          };
        } else {
          return null;
        }
      } else {
        return null;
      }
    }
  };
  return mesh;
};

const _makeMoveMesh = (() => {
  const cornerGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.2, 0.03, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
  ]);
  const browserTargetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)),
  ]);
  const _makeBrowserMesh = () => {
    const material = new THREE.MeshBasicMaterial({
      color: new THREE.Color(0x333333),
    });
    const mesh = new THREE.Mesh(browserTargetGeometry, material);
    mesh.frustumCulled = false;
    return mesh;
  }

  const edgeGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const portalTargetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 1)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 1)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 1)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 1)),
  ]);
  const volumeTargetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    portalTargetGeometry
      .clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5)),
    new THREE.BoxBufferGeometry(0.2, 0.03, 0.03),
    new THREE.BoxBufferGeometry(0.03, 0.1, 0.03).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.1/2, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.03, 0.1).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.1/2)),
  ])
  const _makeVolumeMesh = () => {
    const material = new THREE.MeshBasicMaterial({
      color: new THREE.Color(0x333333),
    });
    const mesh = new THREE.Mesh(volumeTargetGeometry, material);
    mesh.frustumCulled = false;
    mesh.intersect = ray => {
      const intersectionPoint = (() => {
        if (mesh.scale.x >= 0.1 && !currentMoveMeshes.some(moveMesh => moveMesh === mesh)) {
          localMatrix.compose(
            ray.origin,
            localQuaternion.setFromUnitVectors(localVector.set(0, 0, -1), ray.direction),
            localVector2.set(1, 1, 1)
          ).premultiply(
            localMatrix2
              .copy(mesh.matrixWorld)
              .getInverse(localMatrix2)
          ).decompose(localRay.origin, localQuaternion, localVector);
          localRay.direction.set(0, 0, -1).applyQuaternion(localQuaternion);

          // localBox.setFromCenterAndSize(mesh.position, localVector.copy(mesh.scale));
          localBox.setFromCenterAndSize(localVector.set(0, 0, 0), localVector2.set(1, 1, 1));

          return localRay.intersectBox(localBox, localVector);
        } else {
          return null;
        }
      })();

      if (intersectionPoint) {
        material.color.setHex(RAY_COLOR);
        return {
          type: 'move-mesh',
          mesh,
          distance: localRay.origin.distanceTo(intersectionPoint),
          cancel: true,
        };
      } else {
        material.color.setHex(currentMoveMeshes.some(moveMesh => moveMesh === mesh) ? RAY_HIGHLIGHT_COLOR : 0x333333);
        return null;
      }
    };
    return mesh;
  };

  return type => {
    if (type === 'html') {
      return _makeBrowserMesh()
    } else {
      return _makeVolumeMesh();
    }
  };
})();

/* let selectedIconMesh = null;
let selectedIconCoord = new THREE.Vector2(1, 0);
let selectedIconPage = 0;
const _makeIframe = (url, type) => {
  const iframe = document.createElement('iframe');
  iframe.addEventListener('load', () => {
    console.log(`iframe loaded: ${type} ${iframe.src}`);
  });
  iframe.addEventListener('error', err => {
    console.log(`iframe load error: ${type} ${iframe.src} ${err.stack}`);
  });
  iframe.d = type === 'browser' ? 2 : 3;
  iframe.src = url;
  return iframe;
};
const _makeIconMesh = (url, type, onclose) => {
  const mesh = new THREE.Object3D();
  mesh.localVisible = true;
  mesh.iframe = null;
  mesh.model = null;

  console.log('make icon mesh', {type});
  if (type === 'html') {
    // mesh.iframe = _makeIframe(url, type);

    mesh.moveMesh = _makeMoveMesh(type);
  } else if (type === 'model') {
    console.log('load model', url);

    const model = new THREE.Object3D();
    mesh.model = model;

    mesh.moveMesh = _makeMoveMesh(type);

    const loader = new THREE.GLTFLoader();
    function onload(object) {
      // console.log('got object', object);
      object = object.scene;

      model.add(object);
    }
    loader.load(url, onload, xhr => {}, err => {
      const loader = new THREE.LegacyGLTFLoader();
      loader.load(url, onload, xhr => {}, err => {
        console.warn(err.stack);
      });
    });
  }

  mesh.url = url;
  mesh.type = type;
  mesh.x = 0;
  mesh.y = 0;
  mesh.setUrl = s => {
    mesh.url = s;
    mesh.iframe.src = s;
  };
  mesh.setPosition = (newX, newY) => {
    mesh.x = newX;
    mesh.y = newY;
  };
  mesh.scene = null;
  const _makeSetSceneBinding = _save => async newSceneMesh => {
    if (newSceneMesh) {
      const tokenApps = newSceneMesh.token.apps.concat([{
        appType: mesh.type,
        url: mesh.url,
        position: mesh.moveMesh.position.toArray(),
        orientation: mesh.moveMesh.quaternion.toArray(),
      }]);
      const apps = newSceneMesh.apps.concat([mesh]);

      if (_save) {
        await _save(newSceneMesh.token.id, tokenApps);
      }

      newSceneMesh.apps = apps;
      newSceneMesh.token.apps = tokenApps;

      mesh.moveMesh.material.color.setHex(0x9ccc65);
    } else {
      const {scene: oldScene} = mesh;
      if (oldScene) {
        const index = oldScene.apps.indexOf(mesh);
        const tokenApps = oldScene.token.apps.slice();
        tokenApps.splice(index, 1);
        const apps = oldScene.apps.slice();
        apps.splice(index, 1);

        if (_save) {
          await _save(oldScene.token.id, tokenApps);
        }

        oldScene.token.apps = tokenApps;
        oldScene.apps = apps;

        mesh.moveMesh.material.color.setHex(0x333333);
      }
    }
    mesh.scene = newSceneMesh;
  };
  mesh.setSceneBinding = _makeSetSceneBinding(_setSceneApps);
  mesh.setSceneBindingRaw = _makeSetSceneBinding();
  mesh.update = page => {
    const _select = () => {
      mesh.material.uniforms.uColor.value = new THREE.Color(0x9ccc65);
      mesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;

      if (mesh.typeMesh) {
        mesh.typeMesh.visible = true;
      }
      if (mesh.crosshairMesh) {
        mesh.crosshairMesh.visible = true;
      }
      if (mesh.closeMesh) {
        mesh.closeMesh.visible = true;
      }
    };
    const _unselect = () => {
      mesh.material.uniforms.uColor.value = new THREE.Color(0);
      mesh.material.uniforms.uTime.value = 0;

      if (mesh.typeMesh) {
        mesh.typeMesh.visible = false;
      }
      if (mesh.crosshairMesh) {
        mesh.crosshairMesh.visible = false;
      }
      if (mesh.closeMesh) {
        mesh.closeMesh.visible = false;
      }
    };
    if (mesh.parent === selectedIconMesh) {
      let {x, y} = mesh;
      if (pagable) {
        x += 5 * page;

        mesh.visible = x >= 0 && x < 5;
      } else {
        mesh.visible = mesh.localVisible;
      }

      if (mesh.visible) {
        mesh.position.set(-0.8 + x * 0.4, 0.1 + y * 0.3, 0);

        if (mesh.x === selectedIconCoord.x && mesh.y === selectedIconCoord.y) {
          _select();
        } else {
          _unselect();
        }
      }
    } else {
      mesh.visible = false;
    }
  };
  mesh.intersect = ray => {
    if (mesh.visible && img) {
      localMatrix.compose(
        ray.origin,
        localQuaternion.setFromUnitVectors(localVector.set(0, 0, -1), ray.direction),
        localVector2.set(1, 1, 1)
      ).premultiply(
        localMatrix2
          .copy(mesh.matrixWorld)
          .getInverse(localMatrix2)
      ).decompose(localRay.origin, localQuaternion, localVector);
      localRay.direction.set(0, 0, -1).applyQuaternion(localQuaternion);

      if (mesh.crosshairMesh && mesh.crosshairMesh.visible) {
        const intersectionPoint = localRay.intersectBox(localBox.setFromCenterAndSize(mesh.crosshairMesh.position, localVector.copy(mesh.crosshairMesh.scale).multiplyScalar(iconSize)), localVector);
        if (intersectionPoint) {
          return {
            type: 'icon-crosshair',
            distance: localRay.origin.distanceTo(intersectionPoint),
            cancel: true,
            oncrosshair,
          };
        }
      }

      if (mesh.closeMesh && mesh.closeMesh.visible) {
        const intersectionPoint = localRay.intersectBox(localBox.setFromCenterAndSize(mesh.closeMesh.position, localVector.copy(mesh.closeMesh.scale).multiplyScalar(iconSize)), localVector);
        if (intersectionPoint) {
          return {
            type: 'icon-close',
            distance: localRay.origin.distanceTo(intersectionPoint),
            cancel: true,
            onclose,
          };
        }
      }

      const intersectionPoint = localRay.intersectBox(localBox.setFromCenterAndSize(localVector.set(0, 0, 0), localVector2.set(0.2, 0.2, 0.2)), localVector);
      if (intersectionPoint) {
        return {
          type: 'icon',
          distance: localRay.origin.distanceTo(intersectionPoint),
          cancel: true,
          onclick,
        };
      }

      return null;
    } else {
      return null;
    }
  };
  mesh.destroy = () => {
    mesh.iframe && mesh.iframe.destroy && mesh.iframe.destroy();
  };
  return mesh;
};
const _addNewApp = (url, type) => {
  const iconMesh = _makeIconMesh(url, type, () => {
    if (iconMesh.scene) {
      const index = iconMesh.scene.apps.indexOf(iconMesh);
      if (index !== -1) {
        iconMesh.scene.token.apps.splice(index, 1);
        // XXX save
      }
    }

    _removeApp(iconMesh);
    _destroyApp(iconMesh);
  });

  _addApp(iconMesh);
  _moveApp(iconMesh, 1); // XXX use the correct controller index
};
const _addApp = iconMesh => {
  const x = (() => {
    for (let x = 0;; x++) {
      if (screenMesh.appIconMeshes.children.findIndex(mesh => mesh.x === x) === -1) {
        return x;
      }
    }
    return -1;
  })();
  iconMesh.setPosition(x, 0);
  screenMesh.appIconMeshes.add(iconMesh);

  if (iconMesh.iframe) {
    layers.push(iconMesh.iframe);
  }
  if (iconMesh.model) {
    scene.add(iconMesh.model);
  }
  if (iconMesh.moveMesh) {
    scene.add(iconMesh.moveMesh);
  }
};
const _moveApp = (iconMesh, i) => {
  iconMesh.setSceneBinding(null);

  moveSpecs[i] = {
    iconMesh,
    snapSceneMesh: null,
  };
};
const _removeApp = iconMesh => {
  for (let i = 0; i < screenMesh.appIconMeshes.children.length; i++) {
    const child = screenMesh.appIconMeshes.children[i];
    if (child.closeMesh && child.x > iconMesh.x) {
      child.setPosition(child.x - 1, child.y);
    }
  }
  screenMesh.appIconMeshes.remove(iconMesh);

  if (iconMesh.iframe) {
    layers.splice(layers.indexOf(iconMesh.iframe), 1);
  }
  if (iconMesh.model) {
    scene.remove(iconMesh.model);
  }
  if (iconMesh.moveMesh) {
    scene.remove(iconMesh.moveMesh);
  }

  // if (!screenMesh.appIconMeshes.children.some(iconMesh => iconMesh.x === selectedIconCoord.x && iconMesh.y === selectedIconCoord.y)) {
  if (selectedIconMesh === screenMesh.appIconMeshes) {
    if (screenMesh.appIconMeshes.children.some(iconMesh => iconMesh.x === 0 && iconMesh.y === 0)) {
      selectedIconCoord.set(0, 0);
    } else {
      selectedIconMesh = screenMesh.actionIconMeshes;
      selectedIconCoord.set(1, 0);
      selectedIconPage = 0;

      screenMesh.labelMesh.textMesh.setText(DEFAULT_URL);
      screenMesh.labelMesh.visible = true;
    }
  }
};
const _destroyApp = iconMesh => {
  iconMesh.destroy();

  for (let i = 0; i < sceneMeshes.length; i++) {
    const sceneMesh = sceneMeshes[i];
    for (;;) {
      const index = sceneMesh.apps.indexOf(iconMesh);
      if (index !== -1) {
        sceneMesh.apps.splice(index, 1);
      } else {
        break;
      }
    }
  }
}; */

const _makeTrayMesh = () => {
  const geometry = new THREE.PlaneBufferGeometry(2, 0.3)
    .applyMatrix(localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), -Math.PI/2)));
  const material = new THREE.MeshBasicMaterial({
    color: 0x333333,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position
    .copy(camera.position)
    .add(new THREE.Vector3(0, -0.5, -1 + 0.2/2));
  mesh.visible = ['sp', 'mp'].includes(mode);
  mesh.frustumCulled = false;

  const actionIconMeshes = new THREE.Object3D();
  [
    [layersImg, 0, 0, () => {
      const iconMesh = appIconMeshes.children.find(iconMesh => iconMesh.x === 0 && iconMesh.y === 0);
      if (iconMesh) {
        selectedIconMesh = appIconMeshes;
        selectedIconCoord.set(0, 0);
        selectedIconPage = 0;

        labelMesh.textMesh.setText(iconMesh.url);
        settingsMesh.visible = false;
      }
    }],
    [browserImg, 1, 0, () => {
      selectedIconCoord.set(1, 0);
      labelMesh.textMesh.setText('https://google.com');
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
      settingsMesh.visible = false;
    }],
    [diceImg, 2, 0, () => {
      selectedIconCoord.set(2, 0);
      labelMesh.textMesh.setText('https://rawcdn.githack.com/exokitxr/webxr-samples/a8e2c94eba0ee5c9215f20d13057b6c25675d9b0/xr-presentation.html');
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
      settingsMesh.visible = false;
    }],
    [mapImg, 3, 0, () => {
      selectedIconMesh = mapIconMeshes;
      selectedIconCoord.set(3, 0);
      labelMesh.visible = false;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = false;
      mapMesh.localVisible = true;
      settingsMesh.visible = false;
    }],
    [cogsImg, 4, 0, () => {
      selectedIconMesh = settingsIconMeshes;
      // selectedIconCoord.set(-1, 1);
      // selectedIconCoord.set(0, 0);
      labelMesh.visible = false;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = false;
      mapMesh.localVisible = false;
      settingsMesh.visible = true;
    }],
    [plusImg, 5, 1, i => {
      let type = null;
      switch (selectedIconCoord.x) {
        case 1: {
          type = 'browser';
          break;
        }
        case 2: {
          type = 'volume';
          break;
        }
      }
      _addNewApp(labelMesh.textMesh.getText(), faviconImg, type, i);
    }],
  ].forEach(([img, x, y, onclick]) => {
    const iconMesh = _makeIconMesh(null, img, null, onclick, null, null, false);
    iconMesh.setPosition(x, y);
    actionIconMeshes.add(iconMesh);
  });
  mesh.add(actionIconMeshes);
  mesh.actionIconMeshes = actionIconMeshes;

  const appIconMeshes = new THREE.Object3D();
  [
    [arrowLeftImg, -1, 1, () => {
      selectedIconMesh = actionIconMeshes;
      selectedIconCoord.set(1, 0);
      selectedIconPage = 0;

      labelMesh.textMesh.setText(DEFAULT_URL);
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
    }],
    [chevronLeftImg, -1, 0, () => {
      selectedIconPage = Math.max(selectedIconPage - 1, 0);
    }],
    [chevronRightImg, 5, 0, () => {
      selectedIconPage++;
    }],
    [locationImg, 5, 1, () => {
      const iconMesh = appIconMeshes.children.find(iconMesh => iconMesh.x === selectedIconCoord.x && iconMesh.y === selectedIconCoord.y);
      const url = labelMesh.textMesh.getText();
      iconMesh.setUrl(url);
    }],
  ].forEach(([img, x, y, onclick]) => {
    const iconMesh = _makeIconMesh(null, img, null, onclick, null, null, false);
    iconMesh.setPosition(x, y);
    appIconMeshes.add(iconMesh);
  });
  mesh.add(appIconMeshes);
  mesh.appIconMeshes = appIconMeshes;

  const mapIconMeshes = new THREE.Object3D();
  [
    [arrowLeftImg, 0, 1, () => {
      selectedIconMesh = actionIconMeshes;
      selectedIconCoord.set(1, 0);

      labelMesh.textMesh.setText(DEFAULT_URL);
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
    }],
    [chevronUpImg, 4, 1, () => {
      console.log('up');
      if (user && !_isInMultiverse()) {
        mapMesh.positionOffset.y = 0.1;
        mapMesh.minimapMesh.material.uniforms.uType.value = 1;

        for (let i = 0; i < sceneMeshes.length; i++) {
          const sceneMesh = sceneMeshes[i];
          sceneMesh.destroy();
          scene.remove(sceneMesh);
        }
        sceneMeshes.length = 0;
      }
    }],
    [chevronDownImg, 4, 0, () => {
      console.log('down');
      if (_isInMultiverse()) {
        mapMesh.positionOffset.y = 0;
        mapMesh.minimapMesh.material.uniforms.uType.value = 0;

        for (let i = 0; i < sceneMeshes.length; i++) {
          const sceneMesh = sceneMeshes[i];
          sceneMesh.destroy();
          scene.remove(sceneMesh);
        }
        sceneMeshes.length = 0;
      }
    }],
    [saveImg, 4, 2, () => {
      if (selectedSceneToken) {
        const coords = selectedSceneToken.coords.slice();
        const tokenApps = [];
        const apps = [];
        const selectedSceneMeshes = sceneMeshes.filter(sceneMesh => {
          for (let i = 0; i < sceneMesh.token.coords.length; i++) {
            const coord = sceneMesh.token.coords[i];
            for (let j = 0; j < coords.length; j++) {
              const coord2 = coords[j];
              if (coord[0] === coord2[0] && coord[1] === coord2[1]) {
                return true;
              }
            }
          }
          return false;
        });
        for (let i = 0; i < selectedSceneMeshes.length; i++) {
          const sceneMesh = selectedSceneMeshes[i];
          for (let j = 0; j < sceneMesh.apps.length; j++) {
            const iconMesh = sceneMesh.apps[j];
            if (coords.some(coord => {
              const minX = coord[0]*PARCEL_SIZE - PARCEL_SIZE/2 - 0.5;
              const maxX = (coord[0]+1)*PARCEL_SIZE - PARCEL_SIZE/2 - 0.5;
              const minY = coord[1]*PARCEL_SIZE - PARCEL_SIZE/2 - 0.5;
              const maxY = (coord[1]+1)*PARCEL_SIZE - PARCEL_SIZE/2 - 0.5;
              return iconMesh.moveMesh.position.x >= minX && iconMesh.moveMesh.position.x < maxX && iconMesh.moveMesh.position.z >= minY && iconMesh.moveMesh.position.z < maxY;
            })) {
              tokenApps.push(sceneMesh.token.apps[j]);
              apps.push(iconMesh);
            }
          }
        }

        _setScene(coords, tokenApps)
          .then(sceneId => {
            const children = [];
            for (let i = 0; i < selectedSceneMeshes.length; i++) {
              const oldSceneMesh = selectedSceneMeshes[i];
              for (let j = 0; j < oldSceneMesh.apps.length; j++) {
                if (!apps.includes(oldSceneMesh.apps[j])) {
                  _removeApp(iconMesh);
                  _destroyApp(iconMesh);
                }
              }
              children.push.apply(children, oldSceneMesh.children);
              oldSceneMesh.apps = [];
              oldSceneMesh.children = [];
              oldSceneMesh.destroy();
              scene.remove(oldSceneMesh);
              sceneMeshes.splice(sceneMeshes.indexOf(oldSceneMesh), 1);
            }

            const sceneMesh = _makeSceneObjectMesh();
            sceneMesh.token = {
              id: sceneId,
              coords,
              apps: tokenApps,
              owner: _getUserAddress(),
            };
            sceneMesh.apps = apps;
            for (let i = 0; i < children.length; i++) {
              sceneMesh.add(children[i]);
            }
            scene.add(sceneMesh);
            sceneMeshes.push(sceneMesh);

            selectedSceneToken = null;

            lastSceneCoords[0] = NaN;
            lastSceneCoords[1] = NaN;
          });
      }
    }],
  ].forEach(([img, x, y, onclick]) => {
    const iconMesh = _makeIconMesh(null, img, null, onclick, null, null, false);
    iconMesh.setPosition(x, y);
    mapIconMeshes.add(iconMesh);
  });
  mesh.add(mapIconMeshes);

  const settingsIconMeshes = new THREE.Object3D();
  [
    [arrowLeftImg, -1, 1, () => {
      selectedIconMesh = actionIconMeshes;
      selectedIconCoord.set(1, 0);

      labelMesh.textMesh.setText(DEFAULT_URL);
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
      settingsMesh.visible = false;
    }],
  ].forEach(([img, x, y, onclick]) => {
    const iconMesh = _makeIconMesh(null, img, null, onclick, null, null, false);
    iconMesh.setPosition(x, y);
    settingsIconMeshes.add(iconMesh);
  });
  mesh.add(settingsIconMeshes);

  selectedIconMesh = actionIconMeshes;

  const labelMesh = _makeLabelMesh(DEFAULT_URL);
  labelMesh.position.y = 0.4;
  mesh.add(labelMesh);
  mesh.labelMesh = labelMesh;

  const size = PARCEL_SIZE;
  const scale = 0.04;
  const mapMesh = (() => {
    const object = new THREE.Object3D();
    object.positionOffset = new THREE.Vector3();

    object.visible = false;
    object.localVisible = false;
    object.update = () => {
      object.visible = trayMesh.visible && object.localVisible;
      if (object.visible) {
        object.position.copy(trayMesh.position).add(localVector.set(object.positionOffset.x, object.positionOffset.y + 0.2, object.positionOffset.z).applyQuaternion(trayMesh.quaternion));
        mesh.scale.copy(trayMesh.scale).multiplyScalar(scale);
        object.updateMatrixWorld();

        const menuWorldWidth = size;
        const menuWorldHeight = size;
        mesh.leftLine.start
          .set(-menuWorldWidth/2, 0, -menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);
        mesh.leftLine.end
          .set(-menuWorldWidth/2, 0, menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);

        mesh.topLine.start
          .set(-menuWorldWidth/2, 0, menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);
        mesh.topLine.end
          .set(menuWorldWidth/2, 0, menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      }

      for (let i = 0; i < arrowMeshes.length; i++) {
        arrowMeshes[i].update();
      }
    };
    object.intersect = ray => {
      const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
      if (intersectionPoint) {
        const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
        const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

        const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / mesh.width;
        const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / mesh.height;
        const distance = ray.origin.distanceTo(intersectionPoint);

        if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
          const xScale = mesh.width;
          const x = Math.floor(xFactor * size);
          const yScale = mesh.height;
          const y = Math.floor(yFactor * size);

          material.uniforms.uSelect.value.set(x, y);

          return {
            type: 'map',
            // mesh,
            distance,
            cancel: true,
            x: x - Math.floor(size/2),
            y: y - Math.floor(size/2),
            xScale,
            yScale,
          };
        }
      }

      for (let i = 0; i < arrowMeshes.length; i++) {
        const intersection = arrowMeshes[i].intersect(ray);
        if (intersection) {
          return intersection;
        }
      }

      return null;
    };

    const geometry = new THREE.PlaneBufferGeometry(size, size, size, size)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))));
    const mapVsh = `
      varying vec3 vPosition;
      void main() {
        float radius = sqrt(position.x*position.x + position.z*position.z);
        vec3 p = vec3(position.x, position.y, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
        vPosition = position;
      }
    `;
    const mapFsh = `
      uniform float uType;
      uniform vec2 uSelect;
      varying vec3 vPosition;
      void main() {
        vec3 c;
        if (floor(vPosition.x + ${size.toFixed(1)}/2.0) == uSelect.x && floor(vPosition.z + ${size.toFixed(1)}/2.0) == uSelect.y) {
          c = vec3(0.7);
        } else {
          if (uType <= 0.0) {
            c = vec3(0.5);
          } else {
            c = vec3(1.0);
          }
        }
        float a;
        vec3 f = fract(vPosition + 0.5);
        if (f.x <= 0.05 || f.x >= 0.95 || f.z <= 0.05 || f.z >= 0.95) {
          a = 0.0;
        } else {
          a = 1.0;
        }
        gl_FragColor = vec4(c, a);
      }
    `;
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uType: {
          type: 'f',
          value: 0,
        },
        uSelect: {
          type: 'v2',
          value: new THREE.Vector2(),
        },
      },
      vertexShader: mapVsh,
      fragmentShader: mapFsh,
      side: THREE.DoubleSide,
      transparent: true,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.frustumCulled = false;
    mesh.width = size*scale;
    mesh.height = size*scale;
    mesh.plane = new THREE.Plane();
    mesh.leftLine = new THREE.Line3();
    mesh.topLine = new THREE.Line3();
    object.add(mesh);
    object.minimapMesh = mesh;

    const avatarMesh = (() => {
      const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
        new THREE.CylinderBufferGeometry(0.01, 0.05, 0.2, 3, 1)
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.05/2, 0))
          .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
            new THREE.Quaternion().setFromUnitVectors(
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, 0, -1)
            )
          )),
        new THREE.BoxBufferGeometry(0.2, 0.5, 0.1)
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5/2 - 0.1, 0))
      ]).applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, 0));
      const material = new THREE.MeshPhongMaterial({
        color: 0x4caf50,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      return mesh;
    })();
    mesh.add(avatarMesh);

    const arrowMeshes = [
      [
        arrowUpImg,
        'map-arrow-up',
        [0, -1],
      ],
      [
        arrowDownImg,
        'map-arrow-down',
        [0, 1],
      ],
      [
        arrowLeftImg,
        'map-arrow-left',
        [-1, 0],
      ],
      [
        arrowRightImg,
        'map-arrow-right',
        [1, 0],
      ],
    ].map(([img, type, offset]) => {
      const geometry = new THREE.PlaneBufferGeometry(0.1, 0.1)
        .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), -Math.PI/2)));
      const texture = new THREE.Texture(img);
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        alphaTest: 0.01,
        transparent: true,
      });
      const arrowMesh = new THREE.Mesh(geometry, material);
      arrowMesh.position.set(offset[0], 0, offset[1]).multiplyScalar(0.3);
      arrowMesh.frustumCulled = false;
      arrowMesh.width = 0.1;
      arrowMesh.height = 0.1;
      arrowMesh.plane = new THREE.Plane();
      arrowMesh.leftLine = new THREE.Line3();
      arrowMesh.topLine = new THREE.Line3();
      arrowMesh.update = () => {
        arrowMesh.visible = mesh.visible;
        if (arrowMesh.visible) {
          const menuWorldWidth = arrowMesh.width;
          const menuWorldHeight = arrowMesh.height;
          arrowMesh.leftLine.start
            .set(-menuWorldWidth/2, 0, -menuWorldHeight/2)
            .applyMatrix4(arrowMesh.matrixWorld);
          arrowMesh.leftLine.end
            .set(-menuWorldWidth/2, 0, menuWorldHeight/2)
            .applyMatrix4(arrowMesh.matrixWorld);

          arrowMesh.topLine.start
            .set(-menuWorldWidth/2, 0, menuWorldHeight/2)
            .applyMatrix4(arrowMesh.matrixWorld);
          arrowMesh.topLine.end
            .set(menuWorldWidth/2, 0, menuWorldHeight/2)
            .applyMatrix4(arrowMesh.matrixWorld);

          arrowMesh.plane.setFromCoplanarPoints(
            arrowMesh.leftLine.start,
            arrowMesh.leftLine.end,
            arrowMesh.topLine.end
          );
        }
      };
      arrowMesh.intersect = ray => {
        const intersectionPoint = ray.intersectPlane(arrowMesh.plane, localVector);
        if (intersectionPoint) {
          const leftIntersectionPoint = arrowMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
          const topIntersectionPoint = arrowMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(arrowMesh.topLine.start) / arrowMesh.width;
          const yFactor = leftIntersectionPoint.distanceTo(arrowMesh.leftLine.start) / arrowMesh.height;
          const distance = ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const xScale = mesh.width;
            const x = Math.floor(xFactor * size);
            const yScale = mesh.height;
            const y = Math.floor(yFactor * size);

            return {
              type,
              // mesh,
              distance,
              cancel: true,
            };
          }
        }

        return null;
      };

      return arrowMesh;
    });
    for (let i = 0; i < arrowMeshes.length; i++) {
      object.add(arrowMeshes[i]);
    }

    return object;
  })();
  scene.add(mapMesh);
  mesh.mapMesh = mapMesh;

  const settingsMesh = (() => {
    const object = new THREE.Object3D();
    object.position.set(0, 0.5, 0);
    object.visible = false;

    const _makeBorderMesh = (x, y, w, h) => {
      const horizontalGeometry = new THREE.BoxBufferGeometry(1, 0.01, 0.01);
      const verticalGeometry = new THREE.BoxBufferGeometry(0.01, 1, 0.01);
      const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
        horizontalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(w*0.1, 1, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(-w*0.45, h/2, 0)),
        horizontalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(w*0.6, 1, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(w*0.2, h/2, 0)),
        horizontalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(w, 1, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, -h/2, 0)),
        verticalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(1, h, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(w/2, 0, 0)),
        verticalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(1, h, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(-w/2, 0, 0)),
      ]);
      const material = new THREE.MeshBasicMaterial({
        color: 0x333333,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, 0);
      mesh.width = w;
      mesh.height = h;
      mesh.frustumCulled = false;
      return mesh;
    };
    const borderMeshes = [
      _makeBorderMesh(-0.5, 0, 0.9, 0.9),
      _makeBorderMesh(0.5, 0, 0.9, 0.9),
    ];
    borderMeshes.forEach(borderMesh => {
      object.add(borderMesh);
    });

    const _makeSquareMesh = (x, y, w, h) => {
      const horizontalGeometry = new THREE.BoxBufferGeometry(1, 0.01, 0.01);
      const verticalGeometry = new THREE.BoxBufferGeometry(0.01, 1, 0.01);
      const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
        horizontalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(w, 1, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, h/2, 0)),
        horizontalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(w, 1, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, -h/2, 0)),
        verticalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(1, h, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(w/2, 0, 0)),
        verticalGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeScale(1, h, 1))
          .applyMatrix(new THREE.Matrix4().makeTranslation(-w/2, 0, 0)),
      ]);
      const material = new THREE.MeshBasicMaterial({
        color: 0x333333,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, 0);
      mesh.width = w;
      mesh.height = h;
      mesh.frustumCulled = false;
      return mesh;
    };
    const squareMeshes = [
      _makeSquareMesh(-0.735, -0.021, 0.3, 0.1),
      _makeSquareMesh(0.4, -0.021, 0.6, 0.1),
    ];
    squareMeshes.forEach(squareMesh => {
      object.add(squareMesh);
    });

    const leftTextMesh = (() => {
      const textMesh = _makeTextMesh('', 0x000000);
      const mesh = new THREE.Object3D();
      mesh.position.set(-0.85, 0, 0);
      const _update = () => {
        if (user) {
          textMesh.setText(`Player\n${_getShortUserAddress()}\n${0.5} CRD\n${0.0002} trickle\n\n\nLogout`);
        } else {
          textMesh.setText(`Player\n<not logged in>\n\n\n\n\nLog in`);
        }
      };
      _update();
      mesh.update = _update;
      mesh.add(textMesh);
      return mesh;
    })();
    object.add(leftTextMesh);
    object.leftTextMesh = leftTextMesh;
    const rightTextMesh = (() => {
      const textMesh = _makeTextMesh('', 0x000000);
      const mesh = new THREE.Object3D();
      mesh.position.set(0.15, 0, 0);
      const _update = () => {
        if (user) {
          textMesh.setText(`Parcel\n${0},${0}\nOwned by\n${_getShortUserAddress()}\n\n\nBuy for 1 CRD`);
          squareMeshes[1].visible = true;
        } else {
          textMesh.setText(`Parcel\n${0},${0}\nOwned by\n${'0x0'}\n\n\nLog in to buy`);
          squareMeshes[1].visible = false;
        }
      };
      _update();
      mesh.update = _update;
      mesh.add(textMesh);
      return mesh;
    })();
    object.add(rightTextMesh);
    object.rightTextMesh = rightTextMesh;

    const loginButtonMesh = (() => {
      const mesh = new THREE.Object3D();
      mesh.plane = new THREE.Plane();
      mesh.leftLine = new THREE.Line3();
      mesh.topLine = new THREE.Line3();
      const squareMesh = squareMeshes[0];
      mesh.update = () => {
        mesh.leftLine.start
          .set(squareMesh.position.x - squareMesh.width/2, squareMesh.position.y + squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);
        mesh.leftLine.end
          .set(squareMesh.position.x - squareMesh.width/2, squareMesh.position.y - squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);

        mesh.topLine.start
          .set(squareMesh.position.x - squareMesh.width/2, squareMesh.position.y + squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);
        mesh.topLine.end
          .set(squareMesh.position.x + squareMesh.width/2, squareMesh.position.y + squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      };
      mesh.intersect = ray => {
        const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
        if (intersectionPoint) {
          const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
          const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / squareMesh.width;
          const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / squareMesh.height;
          const distance = ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            return {
              type: 'loginButton',
              distance,
              cancel: true,
            };
          }
        }
        return null;
      };
      return mesh;
    })();
    object.add(loginButtonMesh);
    object.loginButtonMesh = loginButtonMesh;

    const buyButtonMesh = (() => {
      const mesh = new THREE.Object3D();
      mesh.plane = new THREE.Plane();
      mesh.leftLine = new THREE.Line3();
      mesh.topLine = new THREE.Line3();
      const squareMesh = squareMeshes[1];
      mesh.update = () => {
        mesh.leftLine.start
          .set(squareMesh.position.x - squareMesh.width/2, squareMesh.position.y + squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);
        mesh.leftLine.end
          .set(squareMesh.position.x - squareMesh.width/2, squareMesh.position.y - squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);

        mesh.topLine.start
          .set(squareMesh.position.x - squareMesh.width/2, squareMesh.position.y + squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);
        mesh.topLine.end
          .set(squareMesh.position.x + squareMesh.width/2, squareMesh.position.y + squareMesh.height/2, 0)
          .applyMatrix4(object.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      };
      mesh.intersect = ray => {
        const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
        if (intersectionPoint) {
          const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
          const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / squareMesh.width;
          const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / squareMesh.height;
          const distance = ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
            const x = Math.floor((c.position.x + PARCEL_SIZE/2) / PARCEL_SIZE);
            const z = Math.floor((c.position.z + PARCEL_SIZE/2) / PARCEL_SIZE);
            return {
              type: 'buyButton',
              distance,
              x,
              z,
              cancel: true,
            };
          }
        }
        return null;
      };
      return mesh;
    })();
    object.add(buyButtonMesh);
    object.buyButtonMesh = buyButtonMesh;

    const sendEthMesh = (() => {
      const mesh = _makeTextMesh('Send ETH', 0x000000);
      mesh.visible = false;
      mesh.plane = new THREE.Plane();
      mesh.leftLine = new THREE.Line3();
      mesh.topLine = new THREE.Line3();
      const menuWorldWidth = 2;
      const menuWorldHeight = 0.1;
      mesh.update = () => {
        mesh.leftLine.start
          .set(0, menuWorldHeight/2, 0)
          .applyMatrix4(object.matrixWorld);
        mesh.leftLine.end
          .set(0, -menuWorldHeight/2, 0)
          .applyMatrix4(object.matrixWorld);

        mesh.topLine.start
          .set(0, menuWorldHeight/2, 0)
          .applyMatrix4(object.matrixWorld);
        mesh.topLine.end
          .set(menuWorldWidth, menuWorldHeight/2, 0)
          .applyMatrix4(object.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      };
      mesh.intersect = ray => {
        const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
        if (intersectionPoint) {
          const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
          const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / menuWorldWidth;
          const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / menuWorldHeight;
          const distance = ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            return {
              type: 'sendEth',
              distance,
              cancel: true,
            };
          }
        }
        return null;
      };
      return mesh;
    })();
    object.add(sendEthMesh);
    object.sendEthMesh = sendEthMesh;
    object.update = () => {
      loginButtonMesh.update();
      buyButtonMesh.update();
      sendEthMesh.update();
    };
    object.intersect = ray => {
      let result = null;
      if (loginButtonMesh.visible && (result = loginButtonMesh.intersect(ray))) {
        return result;
      }
      if (buyButtonMesh.visible && (result = buyButtonMesh.intersect(ray))) {
        return result;
      }
      if (sendEthMesh.visible && (result = sendEthMesh.intersect(ray))) {
        return result;
      }
      return result;
    };
    return object;
  })();
  mesh.add(settingsMesh);
  mesh.settingsMesh = settingsMesh;

  /* labelMesh.textMesh.addEventListener('update', e => {
    const {url} = e;
    if (selectedIconMesh === appIconMeshes) {
      const iconMesh = appIconMeshes.children.find(iconMesh => iconMesh.x === selectedIconCoord.x && iconMesh.y === selectedIconCoord.y);
      iconMesh.setUrl(url);
    }
  }); */

  mesh.getIntersectionCandidates = () => mesh.visible ?
    [labelMesh, keyboardMesh, mapMesh, settingsMesh, floorMesh]
      .concat(actionIconMeshes.children)
      .concat(appIconMeshes.children)
      .concat(mapIconMeshes.children)
      .concat(settingsIconMeshes.children)
      .filter(mesh => mesh.visible)
    : [];

  return mesh;
};
// const trayMesh = _makeTrayMesh();
// scene.add(trayMesh);

let landState = null;
let inventory = [];
const rects = [];
const covers = [];
const _getChildXrIframes = xrIframe => Array.from(xrIframe.contentWindow.iframe.contentDocument.querySelectorAll('xr-iframe'));
const _getUnownedXrIframes = xrIframe => _getChildXrIframes(xrIframe).filter(xrIframe => !/^owned:/.test(xrIframe.id));
const _getOwnedXrIframes = xrIframe => _getChildXrIframes(xrIframe).filter(xrIframe => /^owned:/.test(xrIframe.id));
const _connectLand = async () => {
  if (!landState) {
    let live = true;
    landState = {
      loaded: false,
      disconnect() {
        live = false;
      },
    };

    const xrIframe = document.createElement('xr-iframe');
    xrIframe.src = 'https://root.exokit.org/';
    xrIframe.native = true;
    root.appendChild(xrIframe);
    await new Promise((accept, reject) => {
      xrIframe.addEventListener('load', accept);
      xrIframe.addEventListener('error', reject);
    });
    if (!live) return;
    const xrIframes = _getUnownedXrIframes(xrIframe);

    const _loadInventory = () => {
      fetch(`${LAMBDA_URLS.inventory}?email=${encodeURIComponent(loginToken.email)}&token=${encodeURIComponent(loginToken.token)}`)
        .then(res => res.json())
        .then(newInventory => {
          console.log('got new inventory', newInventory);
          inventory = newInventory;
        });
    };
    _loadInventory();

    const xrExtents = xrIframes.map(xrIframe => {
      const extents = xrIframe.getAttribute('extents');
      return extents ? THREE.Land.parseExtents(extents) : [];
    });
    const _loadMap = () => {
      for (let i = 0; i < xrIframes.length; i++) {
        const xrIframe = xrIframes[i];
        const pixelsList = [];
        const pixels = {};
        let shapeIndexes = 0;
        const iframeIndex = i;
        const xrExtent = xrExtents[i];
        for (let j = 0; j < xrExtent.length; j++) {
          const [x1, y1, x2, y2] = xrExtent[j];
          const shapeIndex = shapeIndexes++;
          for (let x = x1; x <= x2; x++) {
            for (let y = y1; y <= y2; y++) {
              pixelsList.push({x, y, iframeIndex, shapeIndex});
              pixels[`${x}:${y}`] = {
                iframeIndex,
                shapeIndex,
              };
            }
          }
          rects.push({
            ax: x1,
            ay: y1,
            x: x1*40 + 2,
            y: y1*40 + 2,
            w: (x2 - x1 + 1)*40 - 4,
            h: (y2 - y1 + 1)*40 - 4,
          });
        }
        for (let i = 0; i < pixelsList.length; i++) {
          const {x, y, iframeIndex, shapeIndex} = pixelsList[i];
          const _check = (dx, dy) => {
            const ax = x + dx;
            const ay = y + dy;
            const pixel = pixels[`${ax}:${ay}`];
            if (pixel && pixel.iframeIndex === iframeIndex && pixel.shapeIndex !== shapeIndex) {
              if (dx === -1) {
                covers.push({
                  x: ax*40 + 2 + 20,
                  y: ay*40 + 2,
                  w: 40 - 4,
                  h: 40 - 4,
                });
              } else if (dx === 1) {
                covers.push({
                  x: ax*40 + 2 - 20,
                  y: ay*40 + 2,
                  w: 40 - 4,
                  h: 40 - 4,
                });
              } else if (dy === -1) {
                covers.push({
                  x: ax*40 + 2,
                  y: ay*40 + 2 + 20,
                  w: 40 - 4,
                  h: 40 - 4,
                });
              } else if (dy === 1) {
                covers.push({
                  x: ax*40 + 2,
                  y: ay*40 + 2 - 20,
                  w: 40 - 4,
                  h: 40 - 4,
                });
              }
            }
          };
          _check(-1, 0);
          _check(1, 0);
          _check(0, -1);
          _check(0, 1);
        }
      }
    };
    _loadMap();

    const _loadGuardians = () => {
      for (let i = 0; i < xrExtents.length; i++) {
        const xrExtent = xrExtents[i];
        const xrIframe = xrIframes[i];

        const guardianMesh = new THREE.Guardian(xrExtent, 10, colors.default);
        guardianMesh.xrIframe = xrIframe;
        scene.add(guardianMesh);
        guardianMeshes.push(guardianMesh);

        const baseMesh = new THREE.Land(xrExtent, colors.default);
        baseMesh.xrIframe = xrIframe;
        _insertBefore(baseMesh, floorMesh);
        baseMeshes.push(baseMesh);
      }
    };
    _loadGuardians();

    const _loadAssetMoveMeshes = () => Promise.all(xrIframes.map(async extentXrIframe => {
      await new Promise((accept, reject) => {
        if (extentXrIframe.loaded) {
          accept();
        } else {
          extentXrIframe.addEventListener('load', accept);
          extentXrIframe.addEventListener('error', reject);
        }
      });

      const assetXrIframes = _getChildXrIframes(extentXrIframe);
      for (let i = 0; i < assetXrIframes.length; i++) {
        const assetXrIframe = assetXrIframes[i];
        const moveMesh = _makeMoveMesh('volume');
        const {worldOffset} = assetXrIframe;
        moveMesh.position.fromArray(worldOffset.position);
        moveMesh.quaternion.fromArray(worldOffset.orientation);
        moveMesh.scale.fromArray(worldOffset.scale);
        moveMesh.visible = screenMesh.visible;
        moveMesh.xrIframe = assetXrIframe;
        scene.add(moveMesh);
        assetMeshes.push(moveMesh);
        assetXrIframe.moveMesh = moveMesh;

        const labelMesh = _makeLabelMesh(assetXrIframe.name || assetXrIframe.src, 'download');
        labelMesh.visible = screenMesh.visible;
        labelMesh.moveMesh = moveMesh;
        labelMesh.xrIframe = assetXrIframe;
        scene.add(labelMesh);
        assetLabelMeshes.push(labelMesh);

        new assetXrIframe.ownerDocument.defaultView.MutationObserver(mutations => {
          for (let i = 0; i < mutations.length; i++) {
            const mutation = mutations[i];
            const {attributeName} = mutation;
            if (attributeName === 'position') {
              moveMesh.position.fromArray(assetXrIframe.worldOffset.position);
            } else if (attributeName === 'orientation') {
              moveMesh.quaternion.fromArray(assetXrIframe.worldOffset.orientation);
            } else if (attributeName === 'scale') {
              moveMesh.scale.fromArray(assetXrIframe.worldOffset.scale);
            } /* else if (attributeName === 'data') {
              const value = assetXrIframe.getAttribute('data');
            } */
          }
        }).observe(assetXrIframe, {
          attributeFilter: ['position', 'orientation', 'scale', 'data'],
          attributes: true,
        });

        assetXrIframe.setAttributeRaw = assetXrIframe.setAttribute;
        assetXrIframe.setAttribute = (name, value) => {
          assetXrIframe.setAttributeRaw(name, value);

          if (rtcWs) {
            rtcWs.send(JSON.stringify({
              method: 'editState',
              spec: {
                keyPath: [0, '#' + assetXrIframe.id],
                method: 'setAttributes',
                values: [
                  {
                    key: 'position',
                    value: assetXrIframe.getAttribute('position'),
                  },
                  {
                    key: 'orientation',
                    value: assetXrIframe.getAttribute('orientation'),
                  },
                  {
                    key: 'data',
                    value: assetXrIframe.getAttribute('data'),
                  },
                ],
              },
            }));
          }
        };
      }
    })).then(() => {});
    await _loadAssetMoveMeshes();
    if (!live) return;
  }
};
const _disconnectLand = () => {
  if (landState) {
    landState.disconnect();
    landState = null;
  }
};

const uiSize = 2048;
let renderIds = 0;
const _renderUi = (searchResults, inventory, channels, selectedTab, rtcConnected, landConnected) => new Promise((accept, reject) => {
  if (renderIds > 0) {
    uiIframe.contentWindow.postMessage({
      method: 'cancel',
      id: renderIds,
    });
  }
  if (landConnected) {
    searchResults = inventory.map(({src, name}) => ({
      url: src,
      label: name,
      icon: backpackImgBase64,
    }));
  }

  const start = Date.now();

  const mc = new MessageChannel();
  mc.port1.onmessage = e => {
    const {data} = e;
    const {error, result} = data;

    if (result) {
      console.log('time taken', Date.now() - start);

      accept(result);
    } else {
      reject(error);
    }
  };

  uiIframe.contentWindow.postMessage({
    method: 'render',
    id: ++renderIds,
    htmlString: interfaceHtml,
    templateData: {
      searchResults,
      channels: channels.slice(0, 4),
      tab1: selectedTab === 1,
      tab2: selectedTab === 2,
      tab3: selectedTab === 3,
      tab4: selectedTab === 4,
      rects,
      covers,
      localSelected: !rtcConnected && !landConnected,
      landConnected,
      landGridded: landConnected && rects.length > 0,
      landNotGridded: !landConnected || rects.length === 0,
    },
    width: uiSize,
    height: uiSize,
    port: mc.port2,
  }, '*', [mc.port2]);
});
const _renderLabel = (label, type) => new Promise((accept, reject) => {
  if (renderIds > 0) {
    uiIframe.contentWindow.postMessage({
      method: 'cancel',
      id: renderIds,
    });
  }

  const start = Date.now();

  const mc = new MessageChannel();
  mc.port1.onmessage = e => {
    const {data} = e;
    const {error, result} = data;

    if (result) {
      console.log('time taken', Date.now() - start);

      accept(result);
    } else {
      reject(error);
    }
  };

  uiIframe.contentWindow.postMessage({
    method: 'render',
    id: ++renderIds,
    htmlString: labelHtml,
    templateData: {
      label,
      remove: type === 'remove',
      download: type === 'download',
    },
    width: uiSize,
    height: uiSize/8,
    port: mc.port2,
  }, '*', [mc.port2]);
});

const _makeScreenMesh = () => {
  const s = 2;
  const r = s*4/(2*Math.PI);
  const geometry = new THREE.CylinderBufferGeometry(r, r, s, 10, 10, true, Math.PI*3/2+Math.PI/4, Math.PI/2)
    .applyMatrix(new THREE.Matrix4().makeScale(1, 1, -1))
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, r));

  let screenIndex = 0;

  const texture = new THREE.Texture(
    null,
    THREE.UVMapping,
    THREE.ClampToEdgeWrapping,
    THREE.ClampToEdgeWrapping,
    THREE.LinearFilter,
    THREE.LinearMipMapFilter,
    THREE.RGBAFormat,
    THREE.UnsignedByteType,
    16
  );
  /* const texture = new THREE.DataTexture(
    null,
    uiSize,
    uiSize,
    THREE.RGBAFormat,
    THREE.UnsignedByteType,
    THREE.UVMapping,
    THREE.RepeatWrapping,
    THREE.RepeatWrapping,
    THREE.LinearFilter,
    THREE.LinearMipMapFilter,
    16
  ); */

  let items = [];
  let text = 'https://';
  const measures = [];
  let cursor = text.length;
  const canvas = document.createElement('canvas');
  canvas.width = uiSize;
  canvas.height = uiSize;
  const ctx = canvas.getContext('2d');
  ctx.font = '300 80px Open Sans';
  const _updateMeasures = () => {
    measures.length = 0;
    measures.push(0);
    const {width: barWidth} = ctx.measureText('[');
    for (let i = 1; i <= text.length; i++) {
      const {width} = ctx.measureText('[' + text.slice(0, i) + ']');
      measures.push(width - barWidth*2);
    }
  };
  _updateMeasures();
  let searchResults = [];
  const _updateResults = () => {
    searchResults = searchSitesJson(text);
  };
  _updateResults();

  const urlInputPadding = [40, 53];
  const _updateTextureStatic = () => {
    const urlInputAnchor = anchors.find(anchor => anchor.id === 'url-input' || anchor.id === 'channel-input');

    if (urlInputAnchor) {
      ctx.fillStyle = '#f2f3f5';
      ctx.fillRect(urlInputAnchor.x + urlInputPadding[0] - 4, urlInputAnchor.y + urlInputAnchor.height*0.2, urlInputAnchor.width - urlInputPadding[0]*2 + 4, urlInputAnchor.height*0.6);

      ctx.fillStyle = 'black';
      ctx.textBaseline = 'bottom';
      ctx.fillText(text, urlInputAnchor.x + urlInputPadding[0], urlInputAnchor.bottom - urlInputPadding[1]);

      if (keyboardFocus) {
        ctx.fillRect(urlInputAnchor.x + urlInputPadding[0] + measures[cursor] - 4, urlInputAnchor.y + urlInputAnchor.height*0.2, 6, urlInputAnchor.height*0.6);
      }
    }

    texture.image = canvas;
    texture.needsUpdate = true;
  };

  let selectedTab = 1;
  let anchors = [];
  let channels = [];
  const _updateTextureDynamic = async () => {
    for (let i = 0; i < channels.length; i++) {
      const channel = channels[i];
      channel.selected = !!rtcWs && rtcWs.userName === channel.user && rtcWs.channelName.replace(/^.+?\//, '') === channel.channel;
    }
    const t = text.toLowerCase();
    const localChannels = t ?
      channels.filter(channel =>
        channel.selected || channel.user.includes(t) || channel.channel.includes(t) || `${channel.user}/${channel.channel}` === t
      )
    :
      channels.slice();
    localChannels.sort((a, b) => {
      let diff = a.user.localeCompare(b.user);
      if (diff === 0) {
        return a.channel.localeCompare(b.channel);
      } else {
        return diff;
      }
    });
    const result = await _renderUi(searchResults, inventory, localChannels, selectedTab, !!rtcWs, !!landState);
    if (result.data) {
      ctx.putImageData(new ImageData(new Uint8ClampedArray(result.data.buffer, result.data.byteOffset, result.data.byteLength), uiSize, uiSize), 0, 0);
    }
    anchors = result.anchors;
    material.uniforms.uHover.value.set(0, 0, 0, 0);
    // console.log('got anchors', JSON.stringify(anchors));

    _updateTextureStatic();

    /* const img = screenImgs[screenIndex];
    ctx.drawImage(img, 0, 0);

    // const {anchors} = screenJson[screenIndex];

    if (screenIndex === 1) {
      const imgAnchor = anchors.find(anchor => anchor.id === 'img-1');
      const controlDeleteAnchor = anchors.find(anchor => anchor.id === 'control-delete-1');
      const rect = {
        x: imgAnchor.left,
        y: imgAnchor.top - 50,
        width: controlDeleteAnchor.right - imgAnchor.left,
        height: imgAnchor.height + 50*2,
      };
      const imageData = ctx.getImageData(rect.x, rect.y, rect.width, rect.height);

      const nameAnchor = anchors.find(anchor => anchor.id === 'name-1');
      const ownerAnchor = anchors.find(anchor => anchor.id === 'owner-1');
      const bindingAnchor = anchors.find(anchor => anchor.id === 'binding-1');

      ctx.fillStyle = 'white';
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height*5);

      const u = `${LAMBDA_URLS.tokens}/${encodeURIComponent(loginToken.addr)}`;
      items = await fetch(u)
        .then(res => res.json())
        .catch(err => {
          console.warn(err.stack);
        });
      items.forEach((item, i) => {
        ctx.putImageData(imageData, rect.x, rect.y + i*rect.height);

        ctx.fillStyle = 'white';
        ctx.fillRect(nameAnchor.x, nameAnchor.y + i*rect.height, nameAnchor.width, nameAnchor.height);
        ctx.font = '700 50px Open Sans';
        ctx.fillStyle = 'black';
        ctx.textBaseline = 'bottom';
        ctx.fillText(item.name, nameAnchor.x, nameAnchor.bottom + i*rect.height);

        ctx.fillStyle = 'white';
        ctx.fillRect(ownerAnchor.x, ownerAnchor.y + i*rect.height, ownerAnchor.width, ownerAnchor.height);
        ctx.font = '40px Open Sans';
        ctx.fillStyle = 'black';
        ctx.textBaseline = 'bottom';
        ctx.fillText(item.addr.slice(0, 12), ownerAnchor.x, ownerAnchor.bottom + i*rect.height);

        ctx.fillStyle = 'white';
        ctx.fillRect(bindingAnchor.x, bindingAnchor.y + i*rect.height, bindingAnchor.width, bindingAnchor.height);
        ctx.font = '40px Open Sans';
        ctx.fillStyle = 'black';
        ctx.textBaseline = 'bottom';
        ctx.fillText(item.bindingUrl || 'not bound', bindingAnchor.x, bindingAnchor.bottom + i*rect.height);
      });

      createImageBitmap(canvas, {
        imageOrientation: 'flipY',
      })
        .then(imageBitmap => {
          texture.image = imageBitmap;
          texture.needsUpdate = true;
        });
    } else if (screenIndex === 3) {
      const urlInputAnchor = anchors.find(anchor => anchor.id === 'url-input');
      // const imageData = ctx.getImageData(urlInputAnchor.x, urlInputAnchor.y, urlInputAnchor.width, urlInputAnchor.height - 5);

      ctx.fillStyle = 'white';
      ctx.fillRect(urlInputAnchor.x, urlInputAnchor.y, urlInputAnchor.width, urlInputAnchor.height - 5);
      ctx.font = '80px Open Sans';
      ctx.fillStyle = 'black';
      ctx.textBaseline = 'bottom';
      ctx.fillText(text, urlInputAnchor.x, urlInputAnchor.bottom);

      ctx.fillStyle = 'black';
      ctx.fillRect(urlInputAnchor.x + measures[cursor] - 4, urlInputAnchor.y + urlInputAnchor.height*0.2, 6, urlInputAnchor.height*0.8);

      createImageBitmap(canvas, {
        imageOrientation: 'flipY',
      })
        .then(imageBitmap => {
          texture.image = imageBitmap;
          texture.needsUpdate = true;
        });
    } else {
      texture.image = canvas;
      texture.needsUpdate = true;
    } */
  };
  _updateTextureDynamic();

  const screenMeshVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const screenMeshFsh = `
    uniform sampler2D uTex;
    uniform vec4 uHover;
    uniform float uClick;
    varying vec2 vUv;
    vec3 highlightColor = vec3(${new THREE.Color(0x42a5f5).toArray().map(n => n.toFixed(8)).join(',')});
    void main() {
      vec4 c = texture2D(uTex, vUv);
      vec2 uv = vec2(vUv.x, 1.0-vUv.y);
      if (uv.x >= uHover.x && uv.y >= uHover.y && uv.x <= uHover.z && uv.y <= uHover.w) {
        c.rgb = c.rgb*0.6 + highlightColor*0.4;
        if (uClick > 0.0) {
          c.rgb -= 0.1;
        }
      }
      gl_FragColor = c;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTex: {
        type: 't',
        value: texture,
      },
      uHover: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uClick: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: screenMeshVsh,
    fragmentShader: screenMeshFsh,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;

  mesh.intersect = (ray, i) => {
    localRaycaster.ray.copy(ray);
    const intersection = localRaycaster.intersectObject(mesh)[0];
    if (intersection) {
      const {uv, distance} = intersection;
      uv.y = 1-uv.y;
      uv.multiplyScalar(uiSize);
      // const {anchors} = screenJson[screenIndex];
      const anchor = anchors.find(anchor => uv.x >= anchor.left && uv.x <= anchor.right && uv.y >= anchor.top && uv.y <= anchor.bottom) || null;
      if (anchor) {
        material.uniforms.uHover.value.set(anchor.left, anchor.top, anchor.right, anchor.bottom).divideScalar(uiSize);
        material.uniforms.uClick.value = navigator.getGamepads()[i].buttons[1].pressed ? 1 : 0;
      }
      return {
        type: 'screen',
        id: anchor && anchor.id,
        href: anchor && anchor.href,
        name: anchor && anchor.name,
        x: uv.x,
        y: uv.y,
        distance,
        cancel: true,
      };
    } else {
      return null;
    }
  };
  const _selectTab = newSelectedTab => {
    selectedTab = newSelectedTab;
    keyboardFocus = null;
    _updateTextureDynamic();
  };
  mesh.click = async (intersectionSpec, controllerIndex) => {
    keyboardFocus = null;

    const {id, href, name} = intersectionSpec;
    let match;
    if (id === 'url-input' || id === 'channel-input') {
      const {x, y} = intersectionSpec;

      keyboardFocus = {
        textMesh: mesh,
        caretMesh: mesh,
      };

      const urlInputAnchor = anchors.find(anchor => anchor.id === 'url-input' || anchor.id === 'channel-input');
      const xOffset = x - urlInputAnchor.x - urlInputPadding[0];
      cursor = measures.map((measure, index) => [Math.abs(xOffset - measure), index]).sort((a, b) => a[0] - b[0])[0][1];
    } else if (id === 'tab-1') {
      text = 'https://';
      _updateMeasures();
      _updateResults();
      _selectTab(1);
    } else if (id === 'tab-2') {
      _selectTab(2);
    } else if (id === 'tab-3') {
      text = '';
      _updateMeasures();
      _updateResults();
      _selectTab(3);

      const res = await fetch(`${LAMBDA_URLS.presence}channels`)
      if (res.status >= 200 && res.status < 300) {
        channels = await res.json();
        _updateTextureDynamic();
      } else {
        console.warn(`invalid status code: ${res.status}`);
      }
    } else if (id === 'tab-4') {
      _selectTab(4);
    } else if (id === 'action-new-scene') {
      root.innerHTML = '';

      rtcWs && rtcWs.pushScene();
    } else if (id === 'action-copy-scene') {
      const s = root.getHTML();
      console.log('copy', s);
      clipboard.copy(s);
    } else if (id === 'action-paste-scene') {
      const s = await clipboard.paste();
      console.log('paste', s);
      if (root.setHTML(s)) {
        console.log('paste ok');

        rtcWs && rtcWs.pushScene();
      } else {
        console.log('paste fail');
      }
    } else if (id === 'action-load-scene') {
      window.parentPostMessage({
        method: 'loadScene',
      });
    } else if (id === 'action-save-scene') {
      window.parentPostMessage({
        method: 'saveScene',
        html: root.outerHTML,
      });
    } else if (id === 'channel-local') {
      _rtcDisconnect();
      _disconnectLand();
      root.innerHTML = '';
      _updateTextureDynamic();
    } else if (id === 'channel-shared') {
      root.innerHTML = '';
      _rtcDisconnect();
      _disconnectLand();
      const userName = loginToken.name || namegen(2).join('-'); // XXX
      const channelName = namegen(1)[0];
      _rtcConnect('channel', loginToken.name, `${userName}/${channelName}`, state => {
        const htmlString = parse5.serialize(state);
        root.setHTML(htmlString);
      });
      if (!channels.some(channel => channel.user === userName && channel.channel === channelName)) {
        channels.push({
          user: userName,
          channel: channelName,
        });
      }
      mesh.setText(`${userName}/${channelName}`);
    } else if (id === 'channel-global') {
      _disconnectLand();
      _rtcDisconnect();
      root.innerHTML = '';

      _rtcConnect('land', loginToken.name, 'land', async state => {
        await p;

        // emit extent's id'd xr-iframes

        const landXrIframe = root.childNodes[0];
        const extentXrIframes = _getUnownedXrIframes(landXrIframe);
        const assetXrIframes = extentXrIframes.map(extentXrIframe => _getUnownedXrIframes(extentXrIframe)).flat();

        const stateXrSite = state.childNodes.find(node => node.tagName === 'xr-site');
        const stateXrIframes = stateXrSite ? stateXrSite.childNodes.filter(node => node.tagName === 'xr-iframe') : [];
        for (let i = 0; i < stateXrIframes.length; i++) {
          const stateXrIframe = stateXrIframes[i];
          if (stateXrIframe.attrs) {
            const idAttr = stateXrIframe.attrs.find(attr => attr.name === 'id');
            if (idAttr) {
              const id = idAttr.value;
              const assetXrIframe = assetXrIframes.find(xrIframe => xrIframe.id === id);
              if (assetXrIframe) {
                for (let j = 0; j < stateXrIframe.attrs.length; j++) {
                  const attr = stateXrIframe.attrs[j];
                  const {name, value} = attr;
                  assetXrIframe.setAttributeRaw(name, value);
                }
              }
            }
          }
        }
        landState.loaded = true;
      });

      const p = _connectLand();
      _updateTextureDynamic();
      await p;
      rtcWs.pushAssets();
      _updateTextureDynamic();
    } else if (id === 'app' && href) {
      const xrIframe = document.createElement('xr-iframe');
      xrIframe.src = href;
      xrIframe.name = name;
      if (landState) {
        xrIframe.id = `owned:${connectionId}-${_randomString()}`;
      }
      root.appendChild(xrIframe);
      root.update(); // force mutation observer to run

      currentMoveMeshes[controllerIndex] = xrIframe.moveMesh;

      if (rtcWs) {
        const m = {
          method: 'editState',
          spec: {
            keyPath: [0],
            method: 'appendChild',
            value: xrIframe.outerHTML,
          },
        };
        if (landState) {
          for (let i = 0; i < peerConnections.length; i++) {
            const peerConnection = peerConnections[i];
            peerConnection.sendChannel && peerConnection.sendChannel.send(JSON.stringify(m));
          }
        } else {
          rtcWs.send(JSON.stringify(m));
        }
      }
    /* } else if (id && (match = id.match(/^playlist:(.+)$/))) {
      console.log('click playlist', match[1]); // XXX */
    } else if (id && (match = id.match(/^channel(-copy-join|-copy-site)?:(.+?)\/(.+?)$/))) {
      const userName = match[2];
      const channelName = match[3];
      if (!match[1]) {
        _rtcDisconnect();
        _rtcConnect('channel', loginToken.name, `${userName}/${channelName}`, state => {
          const htmlString = parse5.serialize(state);
          root.setHTML(htmlString);
        });
        _updateTextureDynamic();
      } else if (match[1] === '-copy-join') {
        const u = new URL(window.location.href);
        u.pathname = '/';
        u.search = (u.search.length > 1 ? `${u.search}&` : '?') + `j=${encodeURIComponent(`${userName}/${channelName}`)}`;
        clipboard.copy(u.href);
      } else if (match[1] === '-copy-site') {
        clipboard.copy(`https://${userName}.sites.exokit.org/${channelName}`);
      }
    } else if (id && (match = id.match(/^grid:(.+?)-(.+?)$/))) {
      const x = parseInt(match[1], 10);
      const y = parseInt(match[2], 10);

      const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
      const xDest = x;
      const xDist = xDest - vrCamera.position.x;
      const zDest = y;
      const zDist = zDest - vrCamera.position.z;

      window.document.xrOffset.position[0] -= xDist;
      window.document.xrOffset.position[2] -= zDist;
      window.document.xrOffset.pushUpdate();
    } /* else {
      console.log('no match', intersectionSpec, new Error().stack);
    } */

    if (!['tab-1', 'tab-2', 'tab-3', 'tab-4'].includes(id)) {
      _updateTextureStatic();
    }

    /* const {id} = intersectionSpec;
    let match;
    if (match = id.match(/^explore-tab-([0-9]+)$/)) {
      screenIndex = parseInt(match[1], 10) - 1;
      _updateTexture();
    } else if (id === 'url-input') {
      const {x, y} = intersectionSpec;
      const {anchors} = screenJson[screenIndex];
      const urlInputAnchor = anchors.find(anchor => anchor.id === 'url-input');
      const xOffset = x - urlInputAnchor.x;

      cursor = measures.map((measure, index) => [Math.abs(xOffset - measure), index]).sort((a, b) => a[0] - b[0])[0][1];
      _updateTexture();

      keyboardFocus = {
        textMesh: mesh,
        caretMesh: mesh,
      };
    } else if (match = id.match(/^control-move-([0-9]+)$/)) {
      const itemIndex = parseInt(match[1], 10) - 1;
      const item = items[itemIndex];

      console.log('move item', item); // XXX
      _addNewApp(item.url, _getAppType(item.type));
    } else if (match = id.match(/^control-delete-([0-9]+)$/)) {
      const itemIndex = parseInt(match[1], 10) - 1;
      const item = items[itemIndex];
      console.log('delete item', item); // XXX
    } else if (id === 'go') {
      screenMesh.go();
    } else {
      const {href} = intersectionSpec;
      console.log('no match', {id, href}, new Error().stack);
    } */
  };

  mesh.getText = () => text;
  mesh.setText = newText => {
    text = newText;
    _updateMeasures();
    _updateResults();
    _updateTextureDynamic();
  };
  mesh.getValue = () => cursor;
  mesh.setValue = newValue => {
    cursor = newValue;
    _updateTextureStatic();
  };
  mesh.refresh = _updateTextureStatic;

  const keyboardMesh = (() => {
    const object = new THREE.Object3D();

    const planeMesh = (() => {
      const geometry = new THREE.PlaneBufferGeometry(1, keyboardHeight / keyboardWidth);
      const texture = new THREE.Texture(
        keyboardImg,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.LinearFilter,
        THREE.LinearFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        16
      );
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0.9,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      mesh.position.y = -0.5;
      mesh.position.z = 0.8;
      mesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 1, 1).normalize()
      );
      mesh.updateMatrixWorld();

      const keyMeshes = [];
      for (let i = 0; i < 2; i++) {
        const keyMesh = (() => {
          const geometry = new THREE.PlaneBufferGeometry(1, 1);
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.LinearFilter,
            THREE.LinearFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            16
          );
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.frustumCulled = false;
          return mesh;
        })();
        mesh.add(keyMesh);

        keyMeshes.push(keyMesh);
      }
      mesh.keyMeshes = keyMeshes;

      return mesh;
    })();
    object.add(planeMesh);
    object.planeMesh = planeMesh;

    object.plane = new THREE.Plane();
    object.leftLine = new THREE.Line3();
    object.topLine = new THREE.Line3();
    object.update = () => {
      object.leftLine.start
        .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);
      object.leftLine.end
        .set(-1/2, -keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);

      object.topLine.start
        .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);
      object.topLine.end
        .set(1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);

      object.plane.setFromCoplanarPoints(
        object.leftLine.start,
        object.leftLine.end,
        object.topLine.end
      );
    };
    object.intersect = (ray, index) => {
      const intersectionPoint = ray.intersectPlane(keyboardMesh.plane, localVector);
      if (intersectionPoint) {
        const leftIntersectionPoint = keyboardMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
        const topIntersectionPoint = keyboardMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

        const xFactor = topIntersectionPoint.distanceTo(keyboardMesh.topLine.start) / (1);
        const yFactor = leftIntersectionPoint.distanceTo(keyboardMesh.leftLine.start) / (keyboardHeight / keyboardWidth);
        const distance = ray.origin.distanceTo(intersectionPoint);

        if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
          const x = xFactor * keyboardWidth;
          const y = yFactor * keyboardHeight;
          const keyMesh = planeMesh.keyMeshes[index];

          for (let j = 0; j < keyMap.length; j++) {
            const [key, kx1, ky1, kx2, ky2] = keyMap[j];
            if (x >= kx1 && x < kx2 && y >= ky1 && y < ky2) {
              const width = kx2 - kx1;
              const height = ky2 - ky1;
              let imageData = keyboardHighlightCanvasCtx.getImageData(kx1, ky1, width, height);
              if (key === 'enter') { // special case the enter key; it has a non-rectangular shape
                cacheCanvasCtx.putImageData(imageData, 0, 0);
                cacheCanvasCtx.clearRect(0, 0, 80, 140);

                imageData = cacheCanvasCtx.getImageData(0, 0, imageData.width, imageData.height);
              }

              keyMesh.material.map.image = imageData;
              keyMesh.material.map.needsUpdate = true;

              keyMesh.position
                .set(
                  -1/2 + ((width/2 + kx1) / keyboardWidth),
                  (keyboardHeight / keyboardWidth)/2 - ((height/2 + ky1) / keyboardHeight * (keyboardHeight / keyboardWidth)),
                   0.01 * (1)
                );
              keyMesh.scale.set(
                width / keyboardWidth,
                height / keyboardHeight * (keyboardHeight / keyboardWidth),
                1
              );
              keyMesh.updateMatrixWorld();
              keyMesh.visible = true;

              return {
                type: 'key',
                key,
                distance,
                cancel: true,
              };
            }
          }
        }
      }
    };

    return object;
  })();
  mesh.add(keyboardMesh);

  const appIconMeshes = new THREE.Object3D();
  scene.add(appIconMeshes);
  mesh.appIconMeshes = appIconMeshes;

  mesh.update = () => {
    keyboardMesh.update();
    for (let i = 0; i < appIconMeshes.children.length; i++) {
      appIconMeshes.children[i].update();
    }
  };

  mesh.getIntersectionCandidates = () => mesh.visible ?
    [mesh, keyboardMesh]
      // .concat(appIconMeshes.children)
      .concat(moveMeshes)
      .concat(moveLabelMeshes)
      .concat(assetLabelMeshes)
  : [];

  mesh.go = () => {
    const u = `${LAMBDA_URLS.token}?email=${encodeURIComponent(loginToken.email)}&token=${encodeURIComponent(loginToken.token)}&url=${encodeURIComponent(urlInput.value)}`;
    // console.log('open url', u);
    fetch(u, {
      method: 'POST',
    })
      .then(res => {
        if (res.status >= 200 && res.status < 300) {
          return res.json();
        } else {
          throw new Error(`invalid status code: ${res.status}`);
        }
      })
      .then(j => {
        const tokenId = j && j.tokenId;
        const name = j && j.name;
        const url = j && j.url;
        console.log('got token', {tokenId, name, url});
      })
      .catch(err => {
        console.warn(err);
      });
  };

  return mesh;
};
const screenMesh = _makeScreenMesh();
screenMesh.position.set(0, 1.6, -1.25);
scene.add(screenMesh);

const _makeParcelTextMesh = () => {
  const mesh = new THREE.Object3D();
  mesh.visible = false;

  const textMesh = (() => {
    const object = new THREE.Object3D();
    const textMesh = _makeTextMesh('', 0x000000);
    object.add(textMesh);
    object.setText = textMesh.setText.bind(textMesh);
    return object;
  })();
  mesh.add(textMesh);

  let endTime = 0;
  mesh.popup = (x, z) => {
    textMesh.setText(`Parcel ${x},${z} owned by 0x0`);
    if (!mesh.visible) {
      const {position, quaternion, scale} = _getFrontOfCamera();
      mesh.position.copy(position);
      mesh.quaternion.copy(quaternion);
      mesh.scale.copy(scale);
    }

    endTime = Date.now() + 2000;
  };
  mesh.update = () => {
    if (Date.now() < endTime) {
      mesh.visible = true;
      const {position, quaternion} = _getFrontOfCamera();
      mesh.position.lerp(position, 0.1);
      mesh.quaternion.slerp(quaternion, 0.1);
    } else {
      mesh.visible = false;
    }
  };
  return mesh;
};
const parcelTextMesh = _makeParcelTextMesh();
scene.add(parcelTextMesh);

const _makeRoomMesh = (sx, sy, sz, dx, dy, dz, color) => {
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  /* const uvs = geometry.attributes.uv.array;
  const baseUvs = Float32Array.from(uvs);
  const _updateUvs = () => {
    for (let i = 0; i < uvs.length; i += 2) {
      uvs[i] = baseUvs[i] * s;
      uvs[i+1] = baseUvs[i+1] * s;
    }
    geometry.attributes.uv.needsUpdate = true;
  };
  _updateUvs(); */
  const roomVsh = `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vWorldPos = (modelMatrix * vec4(position, 1.)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vNormal = normal;
      // vWorldPos = abs(position);
    }
  `;
  const roomFsh = `
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      // vec2 uv = fract(vUv);
      vec2 uv;
      if (vNormal.x != 0.0) {
        uv = fract(vWorldPos.yz + vec2(0.0, 0.5));
      } else if (vNormal.y != 0.0) {
        uv = fract(vWorldPos.xz + 0.5);
      } else /* if (vNormal.z != 0.0) */ {
        uv = fract(vWorldPos.xy + vec2(0.5, 0.0));
      }
      /* float diff = uv.x;
      diff = min(diff, abs(uv.x - 1.0));
      diff = min(diff, uv.y);
      diff = min(diff, abs(uv.y - 1.0));
      if (diff <= 0.01) { */
      if ((uv.x <= 0.01 || uv.x >= 0.99) || (uv.y <= 0.01 || uv.y >= 0.99)) {
        // gl_FragColor = vec4(uColor * (1.0 - min(diff/0.02, 1.0)), 0.5);
        gl_FragColor = vec4(uColor, 0.5);
      // } else if (abs(abs(uv.x - 0.5) - abs(uv.y - 0.5)) <= 0.01) {
      } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5);
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.5);
      }

      gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      uHighlight: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    mesh.position.set((sx + dx)/2, (sy + dy)/2 + 0.5, (sz + dz)/2);
    mesh.scale.set(Math.abs(dx - sx) + 1, Math.abs(dy - sy) + 1, Math.abs(dz - sz) + 1);
    mesh.updateMatrixWorld();
  };
  mesh.update();
  mesh.getCenter = () => [(sx+dx)/2 + 0.5, (sy+dy)/2 + 0.5, (sz+dz)/2 + 0.5];
  mesh.setEnd = (newDx, newDy, newDz) => {
    dx = newDx;
    dy = newDy;
    dz = newDz;

    mesh.update();
  };
  mesh.setColor = c => {
    mesh.material.uniforms.uColor.value.setHex(c);
  };
  mesh.setHighlight = highlight => {
    mesh.material.uniforms.uHighlight.value = highlight ? 0.2 : 0;
  };
  mesh.contains = position => {
    const box = new THREE.Box3();
    box.expandByPoint(new THREE.Vector3(sx, sy, sz));
    box.expandByPoint(new THREE.Vector3(dx, dy, dz));
    return box.containsPoint(position);
  };
  return mesh;
};
const _makePointMesh = (sx, sy, sz, ox, oy, oz, ow) => {
  const geometry = new THREE.BoxBufferGeometry(0.05, 0.05, 0.05);
  const pointVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const pointFsh = `
    varying vec2 vUv;
    vec3 color = vec3(${new THREE.Color(0xb71c1c).toArray().map(n => n.toFixed(8)).join(',')});
    void main() {
      if ((vUv.x <= 0.01 || vUv.x >= 0.99) || (vUv.y <= 0.01 || vUv.y >= 0.99)) {
        gl_FragColor = vec4(color, 0.5);
      /* } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5); */
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.3);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: pointVsh,
    fragmentShader: pointFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(sx, sy, sz);
  mesh.quaternion.set(ox, oy, oz, ow);
  mesh.frustumCulled = false;
  mesh.setEnd = (sx, sy, sz, ox, oy, oz, ow) => {
    mesh.position.set(sx, sy, sz);
    mesh.quaternion.set(ox, oy, oz, ow);
  };
  mesh.getCenter = () => mesh.position.toArray();

  return mesh;
};
const _getIntersectionCandidates = () => renderScene === scene ?
    screenMesh.getIntersectionCandidates()
  :
    [loginMesh, paymentMesh].flatMap(mesh => mesh.getIntersectionCandidates());
const _makeBrowserMesh = (sx, sy, sz, ox, oy, oz, ow, color) => {
  let dx = sx;
  let dy = sy;
  let dz = sz;

  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const browserVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const browserFsh = `
    varying vec2 vUv;
    vec4 color = vec4(${new THREE.Color(0xb71c1c).toArray().map(n => n.toFixed(8)).join(',')}, 0.5);
    void main() {
      if ((vUv.x < 0.01 || vUv.x > 0.99) || (vUv.y < 0.01 || vUv.y > 0.99)) {
        // gl_FragColor = vec4(1.0, 0.792156862745098, 0.1568627450980392, 1.0);
        gl_FragColor = color;
      } else {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: browserVsh,
    fragmentShader: browserFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  const startPoint = new THREE.Vector3(sx, sy, sz);
  const quaternion = new THREE.Quaternion(ox, oy, oz, ow);
  const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion), startPoint);
  mesh.getCenter = () => mesh.position.toArray();
  mesh.update = () => {
    const endPoint = new THREE.Vector3(dx, dy, dz);
    const upLine = new THREE.Line3(startPoint, startPoint.clone().add(new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion)));
    const rightLine = new THREE.Line3(startPoint, startPoint.clone().add(new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion)));

    endPoint.add(plane.normal.clone().multiplyScalar(-plane.distanceToPoint(endPoint)));
    const midPoint = startPoint.clone().add(endPoint).divideScalar(2);

    const x = rightLine.closestPointToPointParameter(endPoint, false);
    const y = upLine.closestPointToPointParameter(endPoint, false);
    if (x >= -10 && x <= 10 && y >= -10 && y <= 10) {
      mesh.position.copy(midPoint);
      mesh.quaternion.copy(quaternion);
      mesh.scale.set(x, y, 1);
      mesh.updateMatrixWorld();
    }
  };
  mesh.update();
  mesh.setEnd = (newSx, newSy, newSz, newOx, newOy, newOz, newOw) => {
    localRay.set(new THREE.Vector3(newSx, newSy, newSz), new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion(newOx, newOy, newOz, newOw)));
    const intersection = localRay.intersectPlane(plane, new THREE.Vector3());
    if (intersection) {
      dx = intersection.x;
      dy = intersection.y;
      dz = intersection.z;

      mesh.update();
    }
  };
  return mesh;
};
const _makeVolumeMesh = (sx, sy, sz, dx, dy, dz, color) => {
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  const roomVsh = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vPosition = position + 0.5;
      vNormal = normal;
      vUv = uv;
    }
  `;
  const roomFsh = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    uniform vec3 uScale;
    vec4 onColor() {
      return vec4(uColor, 0.5);
    }
    vec4 offColor() {
      if (abs(vUv.x - vUv.y) <= 0.01) {
        return vec4(0.2, 0.2, 0.2, 0.1);
      } else {
        return vec4(0.1, 0.1, 0.1, 0.1);
      }
    }
    void main() {
      vec3 s = vPosition;
      if (vNormal.x != 0.0) {
        if (s.y <= 0.01 || s.y >= 0.99 || s.z <= 0.01 || s.z >= 0.99) {
          gl_FragColor = onColor();
        } else {
          gl_FragColor = offColor();
        }
      } else if (vNormal.y != 0.0) {
        if (s.x <= 0.01 || s.x >= 0.99 || s.z <= 0.01 || s.z >= 0.99) {
          gl_FragColor = onColor();
        } else {
          gl_FragColor = offColor();
        }
      } else /* if (vNormal.z != 0.0) */ {
        if (s.x <= 0.01 || s.x >= 0.99 || s.y <= 0.01 || s.y >= 0.99) {
          gl_FragColor = onColor();
        } else {
          gl_FragColor = offColor();
        }
      }

      gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      uHighlight: {
        type: 'f',
        value: 0,
      },
      uScale: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.material.uniforms.uScale.value = mesh.scale;
  mesh.update = () => {
    mesh.position.set((sx + dx)/2, (sy + dy)/2, (sz + dz)/2);
    mesh.scale.set(Math.abs(dx - sx), Math.abs(dy - sy), Math.abs(dz - sz));
    mesh.updateMatrixWorld();
  };
  mesh.update();
  mesh.getCenter = () => [(sx+dx)/2, (sy+dy)/2, (sz+dz)/2];
  mesh.setEnd = (newDx, newDy, newDz) => {
    dx = newDx;
    dy = newDy;
    dz = newDz;

    mesh.update();
  };
  mesh.setHighlight = highlight => {
    mesh.material.uniforms.uHighlight.value = highlight ? 0.2 : 0;
  };
  mesh.contains = position => {
    const box = new THREE.Box3();
    box.expandByPoint(new THREE.Vector3(sx, sy, sz));
    box.expandByPoint(new THREE.Vector3(dx, dy, dz));
    return box.containsPoint(position);
  };
  return mesh;
};
const _makeRoomLinkMesh = (index, roomMesh) => {
  const geometry = new THREE.BoxBufferGeometry(0.005, 0.005, 1);
  const positions = geometry.attributes.position.array;
  const uvs = geometry.attributes.uv.array;
  for (let i = 0; i < uvs.length; i += 2) {
    uvs[i+1] = positions[i/2*3 + 2] + 0.5;
  }
  const roomLinkVsh = `
    // varying vec3 vWorldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      // vWorldPos = (modelMatrix * vec4(position, 1.)).xyz;
      vUv = uv;
    }
  `;
  const roomLinkFsh = `
    uniform float uTime;
    uniform float uLength;
    // varying vec3 vWorldPos;
    varying vec2 vUv;
    void main() {
      // float d = sqrt(vWorldPos.x*vWorldPos.x + vWorldPos.y*vWorldPos.y + vWorldPos.z*vWorldPos.z);
      // if (mod(d, 0.1) <= 0.05) {
      if (mod(vUv.y * uLength, 0.1) <= 0.05) {
        // gl_FragColor = vec4(0.1607843137254902, 0.7137254901960784, 0.9647058823529412, 1.0); // 29b6f6
        gl_FragColor = vec4(max(vec3(0.1607843137254902, 0.7137254901960784, 0.9647058823529412) * (1.0 - pow(uTime, 0.5)), vec3(0.2)), 1.0);
        // gl_FragColor = vec4(vec3(max(1.0 - pow(uTime, 0.5), 0.1)), 1.0);
        /* if (gl_FragColor.a <= 0.1) {
          discard;
        } */
      } else {
        discard;
        // gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: {
        type: 'f',
        value: 0,
      },
      uLength: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: roomLinkVsh,
    fragmentShader: roomLinkFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.update = () => {
    localVector
      .copy(trayMesh.position)
      .add(localVector2.set(-0.8 + index * 0.4, 0.1, 0).applyQuaternion(trayMesh.quaternion));
    const [cx, cy, cz] = roomMesh.getCenter();
    localVector2.set(cx, cy, cz);

    mesh.position
      .copy(localVector)
      .add(localVector2)
      .divideScalar(2);
    mesh.quaternion.setFromUnitVectors(localVector3.set(0, 0, -1), localVector4.copy(localVector2).sub(localVector).normalize());
    const d = localVector.distanceTo(localVector2);
    mesh.scale.set(1, 1, d);
    mesh.material.uniforms.uLength.value = d;
    mesh.updateMatrixWorld();

    mesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;
  };
  mesh.update();
  return mesh;
};

const portalVsh = `
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    // vUv = uv;
    vWorldPos = position;
  }
`;
const portalFsh = `
  uniform sampler2D uTex;
  uniform sampler2D uDepthTex;
  uniform vec2 uViewport;
  uniform sampler2D uXTex;
  uniform vec4 uPlane;
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform mat4 projectionMatrix;
  float checkPlane(vec4 worldPos, vec4 uPlane) {
    return dot(worldPos.xyz, uPlane.xyz) - uPlane.w;
  }
  // from https://gamedev.stackexchange.com/questions/108856/fast-position-reconstruction-from-depth/111885#111885
  vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer, mat4 projectionMatrixInverse) {
    vec3 clip_space_position = vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - vec3(1.0);
    vec4 view_position = vec4(vec2(projectionMatrixInverse[0][0], projectionMatrixInverse[1][1]) * clip_space_position.xy,
      -1.0,
      projectionMatrixInverse[2][3] * clip_space_position.z + projectionMatrixInverse[3][3]);
    return view_position;
  }
  mat4 inverse(mat4 m) {
    float
        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    return mat4(
        a11 * b11 - a12 * b10 + a13 * b09,
        a02 * b10 - a01 * b11 - a03 * b09,
        a31 * b05 - a32 * b04 + a33 * b03,
        a22 * b04 - a21 * b05 - a23 * b03,
        a12 * b08 - a10 * b11 - a13 * b07,
        a00 * b11 - a02 * b08 + a03 * b07,
        a32 * b02 - a30 * b05 - a33 * b01,
        a20 * b05 - a22 * b02 + a23 * b01,
        a10 * b10 - a11 * b08 + a13 * b06,
        a01 * b08 - a00 * b10 - a03 * b06,
        a30 * b04 - a31 * b02 + a33 * b00,
        a21 * b02 - a20 * b04 - a23 * b00,
        a11 * b07 - a10 * b09 - a12 * b06,
        a00 * b09 - a01 * b07 + a02 * b06,
        a31 * b01 - a30 * b03 - a32 * b00,
        a20 * b03 - a21 * b01 + a22 * b00) / det;
  }
  /* vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    return pmi * vec4(vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - 1.0, 1.0);
  } */
  /* vec2 ndc = (texCoordFull * 2.0) - 1.0;
  float z_n = 2.0 * z_b - 1.0;
  float zNear = projectionMatrix[3][2] / (projectionMatrix[2][2] - 1.0);
  float zFar = projectionMatrix[3][2] / (projectionMatrix[2][2] + 1.0);
  float z_e = 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear)); */
  mat4 viewMatrixInverse = inverse(viewMatrix);
  mat4 projectionMatrixInverse = inverse(projectionMatrix);
  void main() {
    vec2 texCoord = gl_FragCoord.xy / uViewport;
    // gl_FragColor = vec4(texCoord, 0., 1.);
    vec2 texCoordFull = vec2(mod(texCoord.x, 0.5) * 2.0, texCoord.y);
    float z_b = texture2D(uDepthTex, texCoord).r;

    vec4 worldPos = calculate_view_position(texCoordFull, z_b, projectionMatrixInverse);
    worldPos /= worldPos.w;
    worldPos = viewMatrixInverse * worldPos;

    // float p = checkPlane(worldPos, uPlane);
    // if (p >= 0.0) {
      gl_FragColor = texture2D(uTex, texCoord);
      gl_FragDepth = min(gl_FragCoord.z, z_b);
    /* } else {
      if (p >= -0.05) {
        gl_FragColor = texture2D(uXTex, vec2(0., 0.));
      } else {
        gl_FragColor = texture2D(uXTex, vWorldPos.xy * 10.0);
      }
      gl_FragDepth = gl_FragCoord.z;
    } */

    gl_FragColor.rgb += vec3(texCoordFull, 1.0) * 0.2;
  }
`;

const volumeVsh = `
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    // vUv = uv;
    vWorldPos = position;
  }
`;
const volumeFsh = `
  uniform sampler2D uTex;
  uniform sampler2D uDepthTex;
  uniform vec2 uViewport;
  uniform sampler2D uXTex;
  uniform vec4 uPlane0;
  uniform vec4 uPlane1;
  uniform vec4 uPlane2;
  uniform vec4 uPlane3;
  uniform vec4 uPlane4;
  uniform vec4 uPlane5;
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform mat4 projectionMatrix;
  bool checkPlane(vec4 worldPos, vec4 uPlane) {
    return dot(worldPos.xyz, uPlane.xyz) >= uPlane.w;
  }
  // from https://gamedev.stackexchange.com/questions/108856/fast-position-reconstruction-from-depth/111885#111885
  vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer, mat4 projectionMatrixInverse) {
    vec3 clip_space_position = vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - vec3(1.0);
    vec4 view_position = vec4(vec2(pmi[0][0], pmi[1][1]) * clip_space_position.xy,
      -1.0,
      pmi[2][3] * clip_space_position.z + pmi[3][3]);
    return view_position;
  }
  mat4 inverse(mat4 m) {
    float
        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    return mat4(
        a11 * b11 - a12 * b10 + a13 * b09,
        a02 * b10 - a01 * b11 - a03 * b09,
        a31 * b05 - a32 * b04 + a33 * b03,
        a22 * b04 - a21 * b05 - a23 * b03,
        a12 * b08 - a10 * b11 - a13 * b07,
        a00 * b11 - a02 * b08 + a03 * b07,
        a32 * b02 - a30 * b05 - a33 * b01,
        a20 * b05 - a22 * b02 + a23 * b01,
        a10 * b10 - a11 * b08 + a13 * b06,
        a01 * b08 - a00 * b10 - a03 * b06,
        a30 * b04 - a31 * b02 + a33 * b00,
        a21 * b02 - a20 * b04 - a23 * b00,
        a11 * b07 - a10 * b09 - a12 * b06,
        a00 * b09 - a01 * b07 + a02 * b06,
        a31 * b01 - a30 * b03 - a32 * b00,
        a20 * b03 - a21 * b01 + a22 * b00) / det;
  }
  /* vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    return pmi * vec4(vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - 1.0, 1.0);
  } */
  mat4 viewMatrixInverse = inverse(viewMatrix);
  mat4 projectionMatrixInverse = inverse(projectionMatrix);
  void main() {
    vec2 texCoord = gl_FragCoord.xy / uViewport;
    vec2 texCoordFull = vec2(mod(texCoord.x, 0.5) * 2.0, texCoord.y);
    float z_b = texture2D(uDepthTex, texCoord).r;

    vec4 worldPos = calculate_view_position(texCoordFull, z_b, projectionMatrixInverse);
    worldPos /= worldPos.w;
    worldPos = viewMatrixInverse * worldPos;

    vec4 c = texture2D(uTex, texCoord);

    if (
      c.a == 0.0 || (
        checkPlane(worldPos, uPlane0) &&
        checkPlane(worldPos, uPlane1) &&
        checkPlane(worldPos, uPlane2) &&
        checkPlane(worldPos, uPlane3) &&
        checkPlane(worldPos, uPlane4) &&
        checkPlane(worldPos, uPlane5)
      )
    ) {
      gl_FragColor = c;
      gl_FragDepth = z_b;
    } else {
      discard;
      /* if (p >= -0.05) {
        gl_FragColor = texture2D(uXTex, vec2(0., 0.));
      } else {
        gl_FragColor = texture2D(uXTex, vWorldPos.xy * 10.0);
      }
      gl_FragDepth = gl_FragCoord.z; */
    }
  }
`;

const volumeGeometry = (() => {
  const g = new THREE.BoxBufferGeometry(1, 1, 1).toNonIndexed();
  const geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(g.attributes.position.array, 3));
  return geometry;
})();
const _makeContentMesh = (position, quaternion, scale, iframe) => {
  const geometry = volumeGeometry;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTex: {
        type: 't',
        value: null,
      },
      uDepthTex: {
        type: 't',
        value: null,
      },
      uViewport: {
        type: 'v2',
        value: new THREE.Vector2(),
      },
      uXTex: {
        type: 't',
        value: null,
      },
      uPlane0: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane1: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane2: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane3: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane4: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane5: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
    },
    vertexShader: volumeVsh,
    fragmentShader: volumeFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const image = new Image();
  image.src = 'x.png';
  image.onload = () => {
    mesh.material.uniforms.uXTex.value = new THREE.Texture(
      image,
      THREE.UVMapping,
      THREE.RepeatWrapping,
      THREE.RepeatWrapping,
      THREE.LinearFilter,
      THREE.LinearFilter,
      THREE.RGBAFormat,
      THREE.UnsignedByteType,
      16
    );
    mesh.material.uniforms.uXTex.value.needsUpdate = true;
  };
  image.onerror = err => {
    console.warn('fail', err.stack);
  };
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(position);
  mesh.quaternion.copy(quaternion);
  mesh.scale.copy(scale);
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, -scale.y/2, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane0.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, -1, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, scale.y/2, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane1.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(-scale.x/2, 0, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane2.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(-1, 0, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(scale.x/2, 0, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane3.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, 0, -scale.z/2).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane4.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 0, -1).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, 0, scale.z/2).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane5.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  mesh.iframe = iframe;
  return mesh;
};

const cacheCanvas = document.createElement('canvas');
cacheCanvas.width = 1024;
cacheCanvas.height = 1024;
const cacheCanvasCtx = cacheCanvas.getContext('2d');

const secureScene = new THREE.Scene();
secureScene.background = new THREE.Color(0x000000);

const _makeButtonMesh = (text, color, offset, clickOffset, action) => {
  const buttonMesh = _makeTextMesh(text, color);
  buttonMesh.position.set(offset[0], offset[1], 0.01);
  buttonMesh.plane = new THREE.Plane();
  buttonMesh.leftLine = new THREE.Line3();
  buttonMesh.topLine = new THREE.Line3();
  const menuWorldWidth = 0.5;
  const menuWorldHeight = 0.2;
  buttonMesh.update = () => {
    buttonMesh.leftLine.start
      .set(clickOffset[0], clickOffset[1] + menuWorldHeight/2, 0)
      .applyMatrix4(buttonMesh.parent.matrixWorld);
    buttonMesh.leftLine.end
      .set(clickOffset[0], clickOffset[1] - menuWorldHeight/2, 0)
      .applyMatrix4(buttonMesh.parent.matrixWorld);

    buttonMesh.topLine.start
      .set(clickOffset[0], clickOffset[1] + menuWorldHeight/2, 0)
      .applyMatrix4(buttonMesh.parent.matrixWorld);
    buttonMesh.topLine.end
      .set(clickOffset[0] + menuWorldWidth, clickOffset[1] + menuWorldHeight/2, 0)
      .applyMatrix4(buttonMesh.parent.matrixWorld);

    buttonMesh.plane.setFromCoplanarPoints(
      buttonMesh.leftLine.start,
      buttonMesh.leftLine.end,
      buttonMesh.topLine.end
    );
  };
  buttonMesh.intersect = ray => {
    const intersectionPoint = ray.intersectPlane(buttonMesh.plane, localVector);
    if (intersectionPoint) {
      const leftIntersectionPoint = buttonMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
      const topIntersectionPoint = buttonMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

      const xFactor = topIntersectionPoint.distanceTo(buttonMesh.topLine.start) / menuWorldWidth;
      const yFactor = leftIntersectionPoint.distanceTo(buttonMesh.leftLine.start) / menuWorldHeight;
      const distance = ray.origin.distanceTo(intersectionPoint);

      if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
        return {
          type: action,
          distance,
          cancel: true,
        };
      }
    }
    return null;
  };
  return buttonMesh;
};
/* const loginMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(1, 0.5);
  const material = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;

  const textMesh = (() => {
    const mesh = _makeTextMesh('Log in');
    mesh.position.set(-0.45, 0.15, 0.01);
    return mesh;
  })();
  mesh.add(textMesh);

  const labelMesh = _makeLabelMesh('lol');
  labelMesh.position.z = 0.01;
  mesh.add(labelMesh);
  mesh.labelMesh = labelMesh;

  const submitMesh = _makeButtonMesh('Submit', 0x000000, [-0.15, -0.15], [-0.5, -0.125], 'login');
  mesh.add(submitMesh);

  mesh.update = () => {
    labelMesh.update();
    submitMesh.update();
  };
  mesh.getIntersectionCandidates = () => [labelMesh, submitMesh];

  return mesh;
})(); */

const paymentMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(1, 0.5);
  const material = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;

  const textMesh = (() => {
    const mesh = _makeTextMesh('Send 0 ETH to 0x0?');
    mesh.position.set(-0.45, 0.15, 0.01);

    return mesh;
  })();
  mesh.add(textMesh);
  const acceptMesh = _makeButtonMesh('Accept', 0x66bb6a, [-0.35, -0.15], [-0.5, -0.125], 'sendEthAccept');
  mesh.add(acceptMesh);
  const rejectMesh = _makeButtonMesh('Reject', 0xef5350, [0.125, -0.15], [0, -0.125], 'sendEthReject');
  mesh.add(rejectMesh);

  mesh.update = () => {
    acceptMesh.update();
    rejectMesh.update();
  };
  mesh.getIntersectionCandidates = () => [acceptMesh, rejectMesh];

  return mesh;
})();
secureScene.add(paymentMesh);

let renderScene = scene;

// keys

const moves = [null, null];
const keys = {
  up: false,
  down: false,
  left: false,
  right: false,
  r: false,
  f: false,
};
const _makeButtons = () => ({
  trigger: false,
  grip: false,
  menu: false,
});
const lastButtons = [
  _makeButtons(),
  _makeButtons(),
];
const intersectionSpecs = [
  null,
  null,
];
const moveSpecs = [
  null,
  null,
];

const _handleDefaultKey = (code, shiftKey) => {
  let c = String.fromCharCode(code);
  if (!shiftKey) {
    c = c.toLowerCase();
  }
  _handleSingleKey(c);
};
const _handleSingleKey = c => {
  const s = keyboardFocus.textMesh.getText();
  const index = keyboardFocus.caretMesh.getValue();
  keyboardFocus.textMesh.setText(s.slice(0, index) + c + s.slice(index));
  keyboardFocus.caretMesh.setValue(index + 1);
};
const _handleKey = (code, shiftKey, ctrlKey) => {
  // console.log('handle key', code, shiftKey, ctrlKey);
  const s = keyboardFocus.textMesh.getText();
  const index = keyboardFocus.caretMesh.getValue();

  if (code === 8) { // backspace
    if (index > 0) {
      keyboardFocus.textMesh.setText(s.slice(0, index - 1) + s.slice(index));
      keyboardFocus.caretMesh.setValue(index - 1);
    } else {
      /* if (s.length === 0) {
        _closeRig();
      } */
    }
  } else if (code === 46) { // del
    if (index < s.length) {
      keyboardFocus.textMesh.setText(s.slice(0, index) + s.slice(index + 1));
    }
  } else if (code === 32) { // space
    keyboardFocus.textMesh.setText(s.slice(0, index) + ' ' + s.slice(index));
    keyboardFocus.caretMesh.setValue(index + 1);
  } else if (code === 13) { // enter
    const xrIframe = document.createElement('xr-iframe');
    xrIframe.src = s;
    layers.push(xrIframe);

    /* const src = window.location.origin + s.replace(/^[a-z]+:\/\/[a-zA-Z0-9\-\.]+(?:[0-9]+)?/, '');
    const dst = /^[a-z]+:/.test(s) ? (window.location.origin + '/p/' + s) : s;

    console.log('enter', {s, src, dst});

    const mc = new MessageChannel();
    navigator.serviceWorker.controller.postMessage({ // XXX
      method: 'redirect',
      src,
      dst,
    }, [mc.port2]);
    mc.port1.onmessage = () => {
      const xrIframe = document.createElement('xr-iframe');
      xrIframe.src = src;
      layers.push(xrIframe);
    }; */
  } else if (code === 27) { // esc
    // trayMesh.labelMesh.caretMesh.visible = false;
    keyboardFocus = null;
    screenMesh.refresh();
  } else if (
    code === 9 || // tab
    code === 16 || // shift
    code === 17 || // ctrl
    code === 18 || // alt
    code === 20 || // capslock
    code === 91 // win
  ) {
    // nothing
  } else if (code === 37) { // left
    keyboardFocus.caretMesh.setValue(Math.max(index - 1, 0));
  } else if (code === 39) { // right
    keyboardFocus.caretMesh.setValue(Math.min(index + 1, s.length));
  } else if (code === 38) { // up
    // nothing
  } else if (code === 40) { // down
    // nothing
  } else if (code === 86 && ctrlKey) { // V
    // nothing
  } else if (code === 48) { // 0
    _handleSingleKey(shiftKey ? ')' : '0');
  } else if (code === 49) { // 1
    _handleSingleKey(shiftKey ? '!' : '1');
  } else if (code === 50) { // 2
    _handleSingleKey(shiftKey ? '@' : '2');
  } else if (code === 51) { // 3
    _handleSingleKey(shiftKey ? '#' : '3');
  } else if (code === 52) { // 4
    _handleSingleKey(shiftKey ? '$' : '4');
  } else if (code === 53) { // 5
    _handleSingleKey(shiftKey ? '%' : '5');
  } else if (code === 54) { // 6
    _handleSingleKey(shiftKey ? '^' : '6');
  } else if (code === 55) { // 7
    _handleSingleKey(shiftKey ? '&' : '7');
  } else if (code === 56) { // 8
    _handleSingleKey(shiftKey ? '*' : '8');
  } else if (code === 56) { // 9
    _handleSingleKey(shiftKey ? '(' : '9');
  } else if (code === 190) { // .
    _handleSingleKey(shiftKey ? '>' : '.');
  } else if (code === 188) { // ,
    _handleSingleKey(shiftKey ? '<' : ',');
  } else if (code === 191) { // /
    _handleSingleKey(shiftKey ? '?' : '/');
  } else if (code === 186) { // ;
    _handleSingleKey(shiftKey ? ':' : ';');
  } else if (code === 222) { // ;
    _handleSingleKey(shiftKey ? '"': '\'');
  } else if (code === 219) { // [
    _handleSingleKey(shiftKey ? '{' : '[');
  } else if (code === 221) { // ]
    _handleSingleKey(shiftKey ? '}' : ']');
  } else if (code === 189) { // -
    _handleSingleKey(shiftKey ? '_' : '-');
  } else if (code === 187) { // =
    _handleSingleKey(shiftKey ? '+' : '=');
  } else if (code === 220) { // \
    _handleSingleKey(shiftKey ? '|' : '\\');
  } else if (code === -1) {
    // nothing
  } else {
    _handleDefaultKey(code, shiftKey);
  }
};

// let renderTarget = null;
const startTime = Date.now();
let lastTime = 0;
const lastSceneCoords = [NaN, NaN];
function animate(time, frame) {
  const now = Date.now();
  const timeDiff = now - lastTime;
  const startTimeDiff = now - startTime;

  const gamepads = navigator.getGamepads();
  const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
  vrCamera.matrixWorld.decompose(vrCamera.position, vrCamera.quaternion, vrCamera.scale);

  const _updateControllerMeshes = () => {
    // if (renderer.vr.enabled) {
      for (let i = 0; i < controllerMeshes.length; i++) {
        controllerMeshes[i].visible = false;
      }

      for (let i = 0; i < 2; i++) {
        const gamepad = gamepads[i];
        if (gamepad && gamepad.connected) {
          const controllerIndex = _getControllerIndex(gamepad);
          const controllerMesh = controllerMeshes[controllerIndex];
          controllerMesh.position.fromArray(gamepad.pose.position);
          controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
          controllerMesh.updateMatrixWorld(true);
          controllerMesh.visible = true;
        }
      }
    // }
  };
  if (loginToken) {
    _updateControllerMeshes();
  }

  const _updateCurrentMoveMeshes = () => {
    for (let i = 0; i < currentMoveMeshes.length; i++) {
      const moveMesh = currentMoveMeshes[i];
      const controllerMesh = controllerMeshes[i];
      if (moveMesh && controllerMesh.visible) {
        localVector.copy(controllerMesh.position);
        localQuaternion.copy(controllerMesh.quaternion);
        localRay.set(localVector, localVector2.set(0, 0, -1).applyQuaternion(localQuaternion));
        const intersection = floorMesh.intersect(localRay);
        if (intersection) {
          localVector.set(Math.round(intersection.point.x) + 0.5, intersection.point.y, Math.floor(intersection.point.z) + 0.5);
          localEuler.setFromQuaternion(localQuaternion, localEuler.order);
          localEuler.x = 0;
          localEuler.z = 0;
          localEuler.y = Math.round((localEuler.y < 0 ? (localEuler.y+Math.PI*2) : localEuler.y) / (Math.PI/2)) * (Math.PI/2);
          localQuaternion.setFromEuler(localEuler);
        } else {
          localVector.copy(controllerMesh.position).add(localVector2.set(0, 0, -3).applyQuaternion(localQuaternion));
        }

        moveMesh.xrIframe.position = localVector.toArray();
        moveMesh.xrIframe.orientation = localQuaternion.toArray();

        if (rtcWs) {
          const {xrIframe} = moveMesh;
          const index = _getChildNodeIndex(xrIframe);
          const m = {
            method: 'editState',
            spec: {
              keyPath: landState ? [0, '#' + xrIframe.id] : [0, index],
              method: 'setAttributes',
              values: [
                {
                  key: 'position',
                  value: xrIframe.getAttribute('position'),
                },
                {
                  key: 'orientation',
                  value: xrIframe.getAttribute('orientation'),
                },
                {
                  key: 'data',
                  value: xrIframe.getAttribute('data'),
                },
              ],
            },
          };
          if (landState) {
            for (let i = 0; i < peerConnections.length; i++) {
              const peerConnection = peerConnections[i];
              peerConnection.sendChannel && peerConnection.sendChannel.send(JSON.stringify(m));
            }
          } else {
            rtcWs.send(JSON.stringify(m));
          }
        }
      }
    }
  };
  _updateCurrentMoveMeshes();

  const _updateOrbitControls = () => {
    if (orbitControls) {
      orbitControls.update();

      if (fakeXrDisplay) {
        fakeXrDisplay.position.copy(orbitControls.object.position);
        fakeXrDisplay.quaternion.copy(orbitControls.object.quaternion);

        if (window.document.pointerLockElement) {
          fakeXrDisplay.pushUpdate();
        } else {
          fakeXrDisplay.pushHmdUpdate();
          fakeXrDisplay.pushGamepadsUpdate(mouse.position, mouse.quaternion);
        }
      }
    }
  };
  const _updateFakeOrbit = () => {
    const f = (Date.now() % 20000) / 20000;
    const angle = f * Math.PI*2;
    fakeXrDisplay.position.x = 0.5 * Math.cos(angle);
    fakeXrDisplay.position.z = 0.2 * Math.sin(angle);
    fakeXrDisplay.quaternion.setFromUnitVectors(
      localVector.set(0, 0, -1),
      localVector2.set(0, 1.6, -1.25).sub(fakeXrDisplay.position).normalize()
    );
    fakeXrDisplay.pushUpdate();
  };
  const _updateScreenBob = () => {
    const f = (Date.now() % 20000) / 20000;
    screenMesh.position.y = 1.6 + ( .25 * Math.cos(Math.PI*f*10));
  };
  if (loginToken) {
    _updateOrbitControls();
  } else {
    _updateFakeOrbit();
    _updateScreenBob();
  }

  const _updateScreenMesh = () => {
    screenMesh.update();
  };
  _updateScreenMesh();

  /* const _updateSecureScene = () => {
    loginMesh.update();
    paymentMesh.update();
  };
  _updateSecureScene(); */

  /* const _updateParcelTextMesh = () => {
    parcelTextMesh.update();
  };
  _updateParcelTextMesh(); */

  const _updateMoveMeshes = () => {
    for (let i = 0; i < moveMeshes.length; i++) {
      const moveMesh = moveMeshes[i];
      if (moveMesh.visible) {
        if (!menuAnimation) {
          moveMesh.scale.set(1, 1, 1);
          if (!moveMesh.xrIframe.loaded) {
            const f = ((Date.now() - moveMesh.startTime) % 1000) / 1000;
            const angle = Math.pow(f, 0.5) * Math.PI*2;
            moveMesh.scale.multiplyScalar(1 + (1-Math.cos(angle))*0.2);
          }
        }
      }
    }
  };
  _updateMoveMeshes();

  const _updateLabelMeshes = () => {
    const _updateMoveLabelMesh = labelMesh => {
      const {moveMesh} = labelMesh;
      if (moveMesh.visible) {
        const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
        const closestPositionSpec = DIRECTIONS.map((normal, i) => {
          const position = directionVectors[i].copy(moveMesh.position)
            .add(
              localVector2
                .set(normal.x/2, 0.5 + 2/8/2, normal.z/2)
                .applyQuaternion(moveMesh.quaternion)
            );
          return {
            normal,
            position,
            distance: position.distanceTo(vrCamera.position),
          };
        }).sort((a, b) => a.distance - b.distance)[0];

        labelMesh.position.copy(closestPositionSpec.position);
        labelMesh.quaternion.setFromUnitVectors(
          localVector.set(0, 0, 1),
          closestPositionSpec.normal
        ).premultiply(moveMesh.quaternion);
        labelMesh.updateMatrixWorld();
        labelMesh.update();
      }
    };
    for (let i = 0; i < moveLabelMeshes.length; i++) {
      _updateMoveLabelMesh(moveLabelMeshes[i]);
    }
    for (let i = 0; i < assetLabelMeshes.length; i++) {
      _updateMoveLabelMesh(assetLabelMeshes[i]);
    }
    for (let i = 0; i < nativeLabelMeshes.length; i++) {
      const labelMesh = nativeLabelMeshes[i];
      const {position, quaternion} = _getFrontOfCamera();
      labelMesh.position.set(Math.round(position.x), 0.02, Math.round(position.z));
      localEuler.setFromQuaternion(quaternion, localEuler.order);
      localEuler.x = -Math.PI/2;
      localEuler.y = Math.round(localEuler.y/(Math.PI/2))*Math.PI/2;
      localEuler.z = 0;
      labelMesh.quaternion.setFromEuler(localEuler);
    }
  };
  _updateLabelMeshes();

  const _updateGuardianMeshes = () => {
    if (landState) {
      for (let i = 0; i < baseMeshes.length; i++) {
        const baseMesh = baseMeshes[i];
        const {xrIframe} = baseMesh;
        baseMesh.setColor(xrIframe.visible ? colors.highlight : colors.default);
      }
      for (let i = 0; i < guardianMeshes.length; i++) {
        const guardianMesh = guardianMeshes[i];
        const {xrIframe} = guardianMesh;
        guardianMesh.setColor(xrIframe.visible ? colors.highlight : colors.default);
      }
    }
  };
  _updateGuardianMeshes();

  const _updateIntersections = () => {
    for (let i = 0; i < 2; i++) {
      const controllerMesh = controllerMeshes[i];
      if (controllerMesh.visible) {
        controllerMesh.update();

        const candidates = _getIntersectionCandidates();

        const intersections = [];
        for (let j = 0; j < candidates.length; j++) {
          const candidate = candidates[j];
          const intersection = candidate.intersect(controllerMesh.ray, i);
          if (intersection) {
            intersections.push(intersection);
          }
        }
        if (intersections.length > 0) {
          const intersection = intersections.sort((a, b) => a.distance - b.distance)[0];
          intersectionSpecs[i] = intersection;

          controllerMesh.dotMesh.position.z = -intersection.distance;
          controllerMesh.dotMesh.updateMatrixWorld();
          controllerMesh.dotMesh.visible = true;

          controllerMesh.rayMesh.scale.z = intersection.distance;
          controllerMesh.rayMesh.updateMatrixWorld();
        } else {
          controllerMesh.dotMesh.visible = false;

          controllerMesh.rayMesh.scale.z = 1;
          controllerMesh.rayMesh.updateMatrixWorld();

          intersectionSpecs[i] = null;
        }
      }
    }
  };
  _updateIntersections();

  /* const _updateSceneMeshes = () => {
    for (const k in sceneMeshes) {
      sceneMeshes[k].update();
    }
  };
  _updateSceneMeshes(); */

  const _updateAvatarMeshes = () => {
    for (let i = 0; i < avatarMeshes.length; i++) {
      const avatarMesh = avatarMeshes[i];
      avatarMesh.riggedModel && avatarMesh.riggedModel.update();
    }
  };
  _updateAvatarMeshes();

  const _handleTrigger = (gamepad, i, pressed, lastPressed) => {
    const start = pressed && !lastPressed;
    const end = lastPressed && !pressed;

    /* if (pressed && !lastPressed) {
      for (let i = 0; i < roomLabels.length; i++) {
        roomLabels[i].caretMesh.visible = false;
      }
      // keyboardFocus = null;
    } */

    if (pressed && !lastPressed && currentMoveMeshes[i]) {
      currentMoveMeshes[i] = null;
    /* } else if (pressed && !lastPressed && moveSpecs[i]) {
      const moveSpec = moveSpecs[i];
      if (moveSpec.snapSceneMesh) {
        moveSpec.iconMesh.setSceneBinding(moveSpec.snapSceneMesh);
      }
      moveSpecs[i] = null; */
    } else {
      const intersectionSpec = intersectionSpecs[i];
      if (intersectionSpec) {
        if (pressed && !lastPressed) {
          const {type} = intersectionSpec;

          if (type === 'label') {
            const {mesh} = intersectionSpec;
            const glyphs = mesh.getGlyphs();
            const distanceSpecs = glyphs
              .map((c, i) => ({i, x: c.x, distance: Math.abs(intersectionSpec.x - c.x)}))
              .sort((a, b) => a.distance - b.distance);
            const distanceSpec = distanceSpecs.length > 0 ? distanceSpecs[0] : {i: 0, x: 0};
            mesh.caretMesh.setValue(distanceSpec.i);
            mesh.caretMesh.visible = true;
            keyboardFocus = mesh;
          } else if (type === 'icon') {
            intersectionSpec.onclick(i);
          } else if (type === 'icon-crosshair') {
            intersectionSpec.oncrosshair(i);
          } else if (type === 'icon-close') {
            intersectionSpec.onclose(i);
          } else if (type === 'screen') {
            screenMesh.click(intersectionSpec, i);
          } else if (type === 'map') {
            window.document.xrOffset.position[0] += intersectionSpec.x*7 - camera.position.x;
            window.document.xrOffset.position[2] += intersectionSpec.y*7 - camera.position.z;
            window.document.xrOffset.pushUpdate();
          } else if (type === 'map-arrow-up') {
            console.log('click map arrow up');
          } else if (type === 'map-arrow-down') {
            console.log('click map arrow down');
          } else if (type === 'map-arrow-left') {
            console.log('click map arrow left');
          } else if (type === 'map-arrow-right') {
            console.log('click map arrow right');
          } else if (type === 'floor') {
            const x = Math.floor((intersectionSpec.x + PARCEL_SIZE/2) / PARCEL_SIZE);
            const y = Math.floor((intersectionSpec.y + PARCEL_SIZE/2) / PARCEL_SIZE);
            const gamepads = navigator.getGamepads();
            const gripped = !!(gamepads[1] && gamepads[1].buttons[2].pressed);
            const targetScene = (() => {
              for (const k in sceneMeshes) {
                const sceneMesh = sceneMeshes[k];
                if (sceneMesh.token.coords.some(coord => coord[0] === x && coord[1] === y)) {
                  return sceneMesh;
                }
              }
              return null;
            })();
            const targetScenePartiallySelected = !!(targetScene && selectedSceneToken && targetScene.token.coords.some(coord => selectedSceneToken.coords.some(coord2 => coord[0] === coord2[0] && coord[1] === coord2[1])));
            if (selectedSceneToken && !gripped) {
              selectedSceneToken = null;
            }
            if (!selectedSceneToken) {
              selectedSceneToken = {
                id: 0,
                coords: [],
                apps: [],
              };
            }
            const coordsToAdd = (targetScene && !targetScenePartiallySelected) ? targetScene.token.coords.slice() : [[x, y]];
            for (let i = 0; i < coordsToAdd.length; i++) {
              const coordToAdd = coordsToAdd[i];
              const index = selectedSceneToken.coords.findIndex(coord => coord[0] === coordToAdd[0] && coord[1] === coordToAdd[1]);
              if (index !== -1) {
                selectedSceneToken.coords.splice(index, 1);
              } else {
                selectedSceneToken.coords.push([coordToAdd[0], coordToAdd[1]]);
              }
            }
            if (selectedSceneToken.coords.length === 0) {
              selectedSceneToken = null;
            }

            lastSceneCoords[0] = NaN;
            lastSceneCoords[1] = NaN;
          } else if (type === 'mine') {
            const {mesh, intersectionPoint} = intersectionSpec;
            mesh.mine(intersectionPoint);
          } else if (type === 'loginButton') {
            if (!user) {
              getWeb3()
                .then(web3 => {
                  if (web3) {
                    user = web3;

                    trayMesh.settingsMesh.leftTextMesh.update();
                    trayMesh.settingsMesh.rightTextMesh.update();
                    // trayMesh.settingsMesh.sendEthMesh.visible = true;

                    lastSceneCoords[0] = NaN;
                    lastSceneCoords[1] = NaN;
                  } else {
                    for (let i = secureScene.children.length - 1; i >= 0; i--) {
                      secureScene.remove(secureScene.children[secureScene.children.length - 1]);
                    }
                    const {position, quaternion, scale} = _getFrontOfCamera();
                    loginMesh.position.copy(position);
                    localEuler.setFromQuaternion(quaternion, localEuler.order);
                    localEuler.x = 0;
                    localEuler.z = 0;
                    loginMesh.quaternion.setFromEuler(localEuler);
                    loginMesh.scale.copy(scale);
                    secureScene.add(loginMesh);
                    secureScene.add(cameraRig);

                    renderScene = secureScene;
                  }
                });
            } else {
              user = null;

              trayMesh.settingsMesh.leftTextMesh.update();
              trayMesh.settingsMesh.rightTextMesh.update();
              // trayMesh.settingsMesh.sendEthMesh.visible = true;

              lastSceneCoords[0] = NaN;
              lastSceneCoords[1] = NaN;
            }
          } else if (type === 'buyButton') {
            const {x, z} = intersectionSpec;
            if (user) {
              user.execute({
                method: 'buyToken',
                data: {
                  x,
                  y: z,
                  apps: [],
                  tokenPrice: TOKEN_PRICE,
                },
              });
            }
          } else if (type === 'login') {
            const password = loginMesh.labelMesh.textMesh.getText();
            loginMesh.labelMesh.textMesh.setText('');

            makeWeb3(password, ({
              method,
              data,
            }) => {
              for (let i = secureScene.children.length - 1; i >= 0; i--) {
                secureScene.remove(secureScene.children[secureScene.children.length - 1]);
              }
              const {position, quaternion, scale} = _getFrontOfCamera();
              paymentMesh.position.copy(position);
              localEuler.setFromQuaternion(quaternion, localEuler.order);
              localEuler.x = 0;
              localEuler.z = 0;
              paymentMesh.quaternion.setFromEuler(localEuler);
              paymentMesh.scale.copy(scale);
              secureScene.add(paymentMesh);
              secureScene.add(cameraRig);

              renderScene = secureScene;
            })
              .then(web3 => {
                user = web3;

                trayMesh.settingsMesh.loginButtonMesh.visible = false;
                trayMesh.settingsMesh.leftTextMesh.update();
                trayMesh.settingsMesh.rightTextMesh.update();
                scene.add(cameraRig);

                renderScene = scene;

                lastSceneCoords[0] = NaN;
                lastSceneCoords[1] = NaN;
              });
          } else if (type === 'sendEth') {
            user.execute({
              method: 'send',
              data: {
                address: '0x2F4cDC4889CC5022D35aE9eA32A219173B9D63Be',
                value: 10,
                currency: 'ETH',
              },
            })
              .then(() => {
                console.log('send ok');
              })
              .catch(err => {
                console.warn('failed to send', err.stack);
              });
          } else if (type === 'sendEthAccept' || type === 'sendEthReject') {
            scene.add(cameraRig);

            renderScene = scene;
          } else if (type === 'key') {
            if (keyboardFocus) {
              const {key} = intersectionSpec;
              const code = keyCode(key);
              // console.log(`click key: ${key}/${code}`);
              _handleKey(code, false, false);
            }
          } else if (type === 'move-mesh') {
            const {mesh} = intersectionSpec;
            currentMoveMeshes[i] = mesh;
          } else if (type === 'label-mesh') {
            const {id} = intersectionSpec;
            if (id === 'remove') {
              const {labelMesh} = intersectionSpec;
              const {xrIframe} = labelMesh;

              if (rtcWs) {
                const index = _getChildNodeIndex(xrIframe);
                const m = {
                  method: 'editState',
                  spec: {
                    keyPath: [0],
                    method: 'removeChild',
                    key: landState ? ('#' + xrIframe.id) : index,
                  },
                };
                if (landState) {
                  for (let i = 0; i < peerConnections.length; i++) {
                    const peerConnection = peerConnections[i];
                    peerConnection.sendChannel && peerConnection.sendChannel.send(JSON.stringify(m));
                  }
                } else {
                  rtcWs.send(JSON.stringify(m));
                }
              }

              root.removeChild(xrIframe);
            } else if (id === 'download') {
              const {labelMesh} = intersectionSpec;
              const {xrIframe} = labelMesh;
              let {src, name} = xrIframe;
              src = _rewriteUrlToRaw(new URL(src, xrIframe.ownerDocument.baseURI).href);

              fetch(`${LAMBDA_URLS.inventory}add?email=${encodeURIComponent(loginToken.email)}&token=${encodeURIComponent(loginToken.token)}&src=${encodeURIComponent(src)}&name=${encodeURIComponent(name)}`, {
                method: 'POST',
              })
                .then(res => res.blob())
                .then(() => {
                  inventory.push({
                    src,
                    name,
                  });

                  console.log('downloaded to inventory', {src, name});
                });
            }
          } else {
            console.warn(`unknown intersection type ${type}`);
          }
        }
      }
    }
  };
  const _handlePad = (gamepad, i, pad, lastPad) => {
    if (lastPad && !pad) {
      const teleportMesh = teleportMeshes[i];

      if (teleportMesh.visible) {
        const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;

        const xDest = teleportMesh.position.x;
        const xDist = xDest - vrCamera.position.x;
        const zDest = teleportMesh.position.z;
        const zDist = zDest - vrCamera.position.z;

        window.document.xrOffset.position[0] -= xDist;
        window.document.xrOffset.position[2] -= zDist;
        window.document.xrOffset.pushUpdate();
      }
    }
  };
  const _makeMenuAnimation = spec => {
    const startTime = Date.now();
    const endTime = startTime + 1000;
    const curve = cubicBezier(0, 1, 0, 1);
    return {
      spec,
      getValue() {
        return Math.min(Math.max(curve((Date.now() - startTime) / (endTime - startTime)), 0), 1);
      },
    };
  };
  const _updateTrayMeshAnimation = () => {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < 2; i++) {
      const gamepad = gamepads[i];

      if (gamepad) {
        const pressed = gamepad.buttons[1].pressed;
        const lastPressed = lastPresseds[i];
        _handleTrigger(gamepad, i, pressed, lastPressed);
        lastPresseds[i] = pressed;

        const pad = gamepad.buttons[0].pressed || gamepad.axes[1] <= -0.5 || gamepad.axes[3] <= -0.5;
        const lastPad = lastPads[i];
        _handlePad(gamepad, i, pad, lastPad);
        lastPads[i] = pad;

        const menu = gamepad.buttons[5].pressed;
        const lastMenu = lastButtons[i].menu;

        if (menu && !lastMenu) {
          const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
          c.matrixWorld.decompose(localVector, localQuaternion, localVector2);
          localVector.add(localVector2.set(0, -0.2, -1.3).applyQuaternion(localQuaternion));

          if (menuFactor < 0.5) {
            menuAnimation = _makeMenuAnimation({
              start: {
                factor: menuFactor,
                position: localVector.clone(),
                quaternion: localQuaternion.clone(),
                scale: new THREE.Vector3(0.001, 0.001, 0.001),
              },
              end: {
                factor: 1,
                position: localVector.clone(),
                quaternion: localQuaternion.clone(),
                scale: new THREE.Vector3(1, 1, 1),
              },
            });
          } else {
            // console.log('end position', screenMesh.position.clone().toArray().join(','));
            menuAnimation = _makeMenuAnimation({
              start: {
                factor: menuFactor,
                position: screenMesh.position.clone(),
                quaternion: screenMesh.quaternion.clone(),
                scale: new THREE.Vector3(1, 1, 1),
              },
              end: {
                factor: 0,
                position: screenMesh.position.clone(),
                quaternion: screenMesh.quaternion.clone(),
                scale: new THREE.Vector3(0.001, 0.001, 0.001),
              },
            });
          }
        }
        lastButtons[i].menu = menu;

        if (menuAnimation) {
          const {spec: {start, end}} = menuAnimation;
          const f = menuAnimation.getValue();
          menuFactor = start.factor + (end.factor - start.factor) * f;

          screenMesh.quaternion.copy(start.quaternion).slerp(end.quaternion, f);
          screenMesh.position.copy(start.position).lerp(localVector.copy(end.position), f);
          screenMesh.scale.copy(start.scale).lerp(end.scale, f);
          screenMesh.updateMatrixWorld();
          screenMesh.visible = true;

          const _updateMoveMesh = moveMesh => {
            moveMesh.scale.set(menuFactor, menuFactor, menuFactor);
            moveMesh.visible = true;
          };
          for (let i = 0; i < moveMeshes.length; i++) {
            _updateMoveMesh(moveMeshes[i]);
          }
          for (let i = 0; i < assetMeshes.length; i++) {
            _updateMoveMesh(assetMeshes[i]);
          }

          const _updateMoveLabelMesh = labelMesh => {
            labelMesh.scale.set(menuFactor, menuFactor, menuFactor);
            labelMesh.visible = true;
          };
          for (let i = 0; i < moveLabelMeshes.length; i++) {
            _updateMoveLabelMesh(moveLabelMeshes[i]);
          }
          for (let i = 0; i < assetLabelMeshes.length; i++) {
            _updateMoveLabelMesh(assetLabelMeshes[i]);
          }

          for (let i = 0; i < controllerMeshes.length; i++) {
            const controllerMesh = controllerMeshes[i];
            controllerMesh.rayMesh.scale.set(menuFactor, menuFactor, menuFactor);
            controllerMesh.rayMesh.updateMatrixWorld();
            controllerMesh.rayMesh.visible = true;
          }
          skyboxMesh.material.uniforms.uAnimation.value = menuFactor;
          skyboxMesh.visible = true;
          floorMesh.material.uniforms.uAnimation.value = menuFactor;
          floorMesh.visible = true;
          for (let i = 0; i < guardianMeshes.length; i++) {
            const guardianMesh = guardianMeshes[i];
            guardianMesh.material.uniforms.uAnimation.value = menuFactor;
            guardianMesh.visible = true;
          }
          for (let i = 0; i < baseMeshes.length; i++) {
            const baseMesh = baseMeshes[i];
            baseMesh.material.uniforms.uAnimation.value = menuFactor;
            baseMesh.visible = true;
          }
          for (let i = 0; i < nativeLabelMeshes.length; i++) {
            const labelMesh = nativeLabelMeshes[i];
            labelMesh.scale.set(menuFactor, menuFactor, menuFactor);
            labelMesh.visible = true;
          }
          /* const opening = start.factor < end.factor;
          for (let i = 0; i < sceneMeshes.length; i++) {
            sceneMeshes[i].visible = opening;
          } */

          if (f >= 1) {
            if (end.factor === 0) {
              screenMesh.visible = false;

              for (let i = 0; i < moveMeshes.length; i++) {
                moveMeshes[i].visible = false;
              }
              for (let i = 0; i < assetMeshes.length; i++) {
                assetMeshes[i].visible = false;
              }
              for (let i = 0; i < moveLabelMeshes.length; i++) {
                moveLabelMeshes[i].visible = false;
              }
              for (let i = 0; i < assetLabelMeshes.length; i++) {
                assetLabelMeshes[i].visible = false;
              }
              for (let i = 0; i < nativeLabelMeshes.length; i++) {
                nativeLabelMeshes[i].visible = false;
              }

              for (let i = 0; i < controllerMeshes.length; i++) {
                controllerMeshes[i].rayMesh.visible = false;
              }
              skyboxMesh.visible = false;
              floorMesh.visible = false;
              for (let i = 0; i < guardianMeshes.length; i++) {
                guardianMeshes[i].visible = false;
              }
              for (let i = 0; i < baseMeshes.length; i++) {
                baseMeshes[i].visible = false;
              }
            }
            menuAnimation = null;
          }
        }
      }
    }
  };
  _updateTrayMeshAnimation();

  const _updateTeleportMeshes = () => {
    for (let i = 0; i < teleportMeshes.length; i++) {
      teleportMeshes[i].visible = false;
    }

    for (let i = 0; i < 2; i++) {
      const gamepad = gamepads[i];
      if (gamepad && (gamepad.buttons[0].pressed || gamepad.axes[1] <= -0.5 || gamepad.axes[3] <= -0.5)) {
        const controllerIndex = _getControllerIndex(gamepad);
        const teleportMesh = teleportMeshes[controllerIndex];

        localVector2.fromArray(gamepad.pose.position);
        localEuler.setFromQuaternion(localQuaternion.fromArray(gamepad.pose.orientation), localEuler.order);

        for (let i = 0; i < 20; i++, localVector2.add(localVector3), localEuler.x = Math.max(localEuler.x - Math.PI*0.07, -Math.PI/2)) {
          localRay.set(localVector2, localVector3.set(0, 0, -1).applyQuaternion(localQuaternion.setFromEuler(localEuler)));
          const intersection = floorMesh.intersect(localRay);
          if (intersection && intersection.distance <= 1) {
            teleportMesh.position.copy(intersection.point);
            localEuler.setFromQuaternion(localQuaternion, localEuler.order);
            localEuler.x = 0;
            localEuler.z = 0;
            teleportMesh.quaternion.setFromEuler(localEuler);
            teleportMesh.updateMatrixWorld(true);
            teleportMesh.visible = true;
            break;
          }
        }
      }
    }
  };
  if (loginToken) {
    _updateTeleportMeshes();
  }

  const _render = () => {
    const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;

    /* c.matrixWorld.decompose(pointerMesh.position, localQuaternion, localVector2);
    pointerMesh.position.add(localVector.set(0, 0, -1).applyQuaternion(c.quaternion));
    pointerMesh.rotation.x += 0.1;
    pointerMesh.rotation.z += 0.1;

    for (let i = 0; i < roomLinks.length; i++) {
      roomLinks[i].update();
    }
    for (let i = 0; i < roomDiagrams.length; i++) {
      roomDiagrams[i].update();
    } */

    renderer.render(renderScene, c);
  };
  _render();

  const _updateMovement = () => {
    if (fakeXrDisplay && window.document.pointerLockElement) {
      // let moving = false;
      const speed = 0.004;
      const velocity = localVector.set(0, 0, 0);
      if (keys.up) {
        velocity.z -= speed * timeDiff;
        // moving = true;
      }
      if (keys.down) {
        velocity.z += speed * timeDiff;
        // moving = true;
      }
      if (keys.left) {
        velocity.x -= speed * timeDiff;
        // moving = true;
      }
      if (keys.right) {
        velocity.x += speed * timeDiff;
        // moving = true;
      }
      if (keys.r) {
        velocity.y += speed * timeDiff;
        // moving = true;
      }
      if (keys.f) {
        velocity.y -= speed * timeDiff;
        // moving = true;
      }

      // if (moving) {
        // velocity.multiplyScalar(Math.pow(moving ? 0.98 : 0.91, timePassed / 5));
        localEuler.setFromQuaternion(fakeXrDisplay.quaternion, localEuler.order);
        localEuler.x = 0;
        fakeXrDisplay.position.add(
          localVector.copy(velocity)
            .applyEuler(localEuler)
        );
        fakeXrDisplay.pushUpdate();
      // }
    }
  };
  _updateMovement();

  lastTime = now;
}

// bootstrap

const _startFakeVrDisplay = async () => {
  if (typeof FakeXRDisplay !== 'undefined') {
    fakeXrDisplay = new FakeXRDisplay();
    fakeXrDisplay.position.copy(camera.position);
    fakeXrDisplay.pushUpdate();
    fakeXrDisplay.enable();
    await _enterXr();
  } else {
    fakeXrDisplay = {
      position: camera.position.clone(),
      quaternion: camera.quaternion.clone(),
      get viewMatrix() {
        return camera.matrixWorldInverse.toArray(new Float32Array(16));
      },
      get projectionMatrix() {
        return camera.projectionMatrix.toArray(new Float32Array(16));
      },
      enable() {},
      disable() {},
      pushHmdUpdate(position = this.position, quaternion = this.quaternion) {
        camera.position.copy(this.position);
        camera.quaternion.copy(this.quaternion);
        camera.matrix
          .compose(camera.position, camera.quaternion, camera.scale)
          .premultiply(localMatrix.fromArray(window.document.xrOffset.matrix))
          .decompose(camera.position, camera.quaternion, camera.scale);
        // console.log('pre', window.document.xrOffset.matrix.join(','), window.document.xrOffset.inverse.matrix.join(','));
        camera.updateMatrixWorld();
        // camera.matrixWorld.copy(camera.matrix);
        // camera.matrixWorldInverse.getInverse(camera.matrixWorld);
      },
      pushGamepadsUpdate(position = this.position, quaternion = this.quaternion) {
        position.toArray(gamepad.pose.position);
        quaternion.toArray(gamepad.pose.orientation);
      },
      pushUpdate() {
        this.pushHmdUpdate();
        this.pushGamepadsUpdate(
          localVector
            .copy(this.position)
            .add(localVector2.set(0.5, -0.3, -0.5).applyQuaternion(this.quaternion))
            .add(localVector2.fromArray(window.document.xrOffset.position))
        );
      },
    };
    fakeXrDisplay.enable();

    renderer.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio, false);

    const gamepad = {
      hand: 'right',
      pose: {
        position: [0, 0, 0],
        orientation: [0, 0, 0, 1],
      },
      buttons: [
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
      ],
      connected: true,
    };
    navigator.getGamepads = () => [null, gamepad];

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      renderer.setPixelRatio(window.devicePixelRatio);
    });

    window.document.xrOffset = {
      position: new Float32Array(3),
      orientation: Float32Array.from([0, 0, 0, 1]),
      scale: Float32Array.from([1, 1, 1]),
      matrix: Float32Array.from([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      matrixInverse: Float32Array.from([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      inverse: {
        matrix: null,
      },
      pushUpdate() {
        localMatrix
          .compose(
            localVector.fromArray(this.position),
            localQuaternion.fromArray(this.orientation),
            localVector2.fromArray(this.scale)
          )
          .toArray(this.matrix);
        localMatrix
          .getInverse(localMatrix)
          .toArray(this.matrixInverse);
      },
    };
    window.document.xrOffset.inverse.matrix = window.document.xrOffset.matrixInverse;
  }

  window.addEventListener('popstate', () => {
    window.location.reload();
  });

  renderer.setAnimationLoop(animate);
};
const _endFakeVrDisplay = async () => {
  renderer.vr.enabled = false;
  // renderer.vr.setSession(null);
  // renderer.vr.setDevice(null);
  renderer.vr.setAnimationLoop(null);

  if (session) {
    await session.end();
    session = null;
  } else if (display) {
    await display.exitPresent();
    display = null;
  }

  fakeXrDisplay.disable();
  fakeXrDisplay = null;

  // renderer.domElement.framebuffer = null; // XXX destroy this framebuffer
};
const _enterXr = async () => {
  if (navigator.xr) { // WebXR
    session = await navigator.xr.requestSession({
      exclusive: true,
    });
    session.layers = layers;

    // console.log('request first frame');
    session.requestAnimationFrame((timestamp, frame) => {
      renderer.vr.setSession(session, {
        frameOfReferenceType: 'stage',
      });

      const pose = frame.getViewerPose();
      const viewport = session.baseLayer.getViewport(pose.views[0]);
      // const width = viewport.width;
      const height = viewport.height;
      const fullWidth = (() => {
        let result = 0;
        for (let i = 0; i < pose.views.length; i++) {
          result += session.baseLayer.getViewport(pose.views[i]).width;
        }
        return result;
      })();
      renderer.setSize(fullWidth, height);
      renderer.setPixelRatio(1);

      renderer.setAnimationLoop(null);

      renderer.vr.enabled = true;
      renderer.vr.setSession(session);
      renderer.vr.setAnimationLoop(animate);

      console.log('loaded root in XR');
    });
  } else { // WebVR
    console.log('request device');
    const displays = await navigator.getVRDisplays();
    display = displays[0];

    if (display) {
      console.log('request present');
      await display.requestPresent([
        {
          source: renderer.domElement,
        }
      ]);
      console.log('entered vr');

      display.layers = layers;

      const {renderWidth: width, renderHeight: height} = display.getEyeParameters('left');
      const fullWidth = width * 2;
      renderer.setSize(fullWidth, height);
      renderer.setPixelRatio(1);

      renderer.setAnimationLoop(null);
      renderer.vr.enabled = true;
      renderer.vr.setDevice(display);
      renderer.vr.setAnimationLoop(animate);

      console.log('loaded root in XR');
    } else {
      console.log('no vr displays');
    }
  }
};
const _enter2d = () => {
  if (!window.document.pointerLockElement) {
    renderer.domElement.requestPointerLock();
  }
};
_startFakeVrDisplay()
  .then(() => {
    _bindEventTarget('ui');
  })
  .catch(err => {
    console.warn(err.stack);
  });

const avatarMeshes = [];
const _mod = (v, d) => {
  const n = v % d;
  return n < 0 ? (d + n) : n;
};
const _angleDiff = (a, b) => _mod((b - a) + Math.PI, Math.PI * 2) - Math.PI;

scene.add(defaultGltf);
const _loadDefaultGltf = () => {
  const loader = new THREE.GLTFLoader();
  // const loader = new THREE.LegacyGLTFLoader();
  loader.load('model/sketch.gltf', object => {
    object = object.scene;

    defaultGltf.add(object);
    defaultGltf.position.set(-0.5, 0, -1);
    defaultGltf.scale.setScalar(2);
  }, xhr => {}, err => {
    console.warn(err.stack);
  });
};
_loadDefaultGltf();

function _updateCoord() {
  const {c} = parseQuery(window.location.search);
  let match;
  if (c && (match = c.match(/^(-?[0-9\.]+),(-?[0-9\.]+)$/))) {
    const x = parseFloat(match[1]);
    const z = parseFloat(match[2]);
    if (isFinite(x) && isFinite(z)) {
      window.document.xrOffset.position[0] += x - camera.position.x;
      window.document.xrOffset.position[2] += z - camera.position.z;
      window.document.xrOffset.pushUpdate();
    }
  }
}
_updateCoord();
window.addEventListener('popstate', _updateCoord);

console.log('app started');

})();
    </script>
    <!-- <audio src="background.mp3" autoplay loop></audio> -->
  </body>
</html>
